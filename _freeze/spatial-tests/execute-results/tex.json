{
  "hash": "ada877023aef046af683eb6f8fe89627",
  "result": {
    "markdown": "---\ntitle: \"Tests for patterns\"\neditor_options: \n  chunk_output_type: inline\n---\n\n\n\n::: {.callout-note appearance=\"simple\"}\nThis is a work in progress that is currently undergoing heavy technical editing and copy-editing\n:::\n\nA range of techniques, most based on statistical tests, can be used to detect deviations from randomness in space and the choice of the methods depends on the question, the nature of the data and scale of observation. Usually, more than one test is applied for the same or different scales of interest depending on how the data are collected.\n\nThe several exploratory or inferential methods can be classified based on the spatial scale and type of data (binary, count, etc.) collected, but mainly if the spatial location of the unit is known (mapped) or not known (sampled). Following @madden2017, two major groups can be formed. The first group uses intensively mapped data for which the location \\[x,y\\] of the sampling unit is known. Examples of data include binary data (plant is infected or not infected) in planting row, point pattern (spatial arrangements of points in a 2-D space) and quadrat data (grids are superimposed on point pattern data). The second group is the sparsely sampled data in the form of count or proportion (incidence) data for which the location is not known or, if known, not taken into account in the analysis.\n\n![Classification of spatial data and methods used to study spatial patterns of plant disease based on knowledge of the location of the sampling units and nature of the data.](imgs/spatial_methods.png){#fig-spatialmethods}\n\n## Intensively mapped\n\n### Binary data\n\nIn this situation the individual plants are mapped, meaning that their relative positions to one another are known. It is the case when a census is used to map presence/absence data. The status of each unit (usually a plant) is noted as a binary variable. The plant is either diseased (D or 1) or non-diseased or healthy (H or 0). Several statistical tests can be used to detect a deviation from randomness. The most commonly used tests are runs, doublets and join count.\n\n#### Runs test\n\nA **run** is defined as a succession of *one or more* diseased (D) or healthy (H) plants, which are followed and preceded by a plant of the other disease status or no plant at all. In the example below, we can count 13 runs.\n\n![Example for the computation of the number of ordinary runs in a sequence of binary data](imgs/runs.png){#fig-runs1 fig-align=\"center\" width=\"391\"}\n\nThere would be few runs if there is an aggregation of diseased or healthy plants and a large number of runs for a random mixing of diseased and healthy plants.\n\nLet's create a vector of binary (0 = non-diseased; 1 = diseased) data representing a crop row with 20 plants and assign it to `y`. For plotting purposes, we make a dataframe for more complete information.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-1_05431647833d57d50ac4a9b9ae63addd'}\n\n```{.r .cell-code}\nlibrary(tidyverse) \ntheme_set(theme_bw(base_size = 16))\n```\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-2_2aa7901d9ad61306cec536760a8d59fd'}\n\n```{.r .cell-code}\ny1 <- c(1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,1,1)\nx1 <- c(1:20) # position of each plant\nz1 <- 1\nrow1 <- data.frame(x1, y1, z1) # create a dataframe\n```\n:::\n\n\n\nWe can then visualize the series using ggplot and count the number of runs as 7, aided by the color used to identify a run.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-runs_b55027ac784c669f99414ac17c782e61'}\n\n```{.r .cell-code}\nrow1 |>\n  ggplot(aes(x1, z1, label = x1, color = factor(y1))) +\n  geom_point(shape = 15, size = 7) +\n  theme_void() +\n  scale_x_continuous(breaks = max(z1)) +\n  scale_color_manual(values = c(\"gray70\", \"darkred\")) +\n  geom_text(vjust = 0, nudge_y = 0.5) +\n  coord_fixed() +\n  ylim(0, 2.5) +\n  theme(legend.position = \"top\") +\n  labs(color = \"Status\")\n```\n\n::: {.cell-output-display}\n![Sequence of diseased (1) or non-diseased (0) units (plants). The numbers represent the position of the unit](spatial-tests_files/figure-pdf/fig-runs-1.pdf){#fig-runs fig-pos='H'}\n:::\n:::\n\n\n\nWe can obtain the number of runs and related statistics using the `oruns.test()` function of the *r4pde* package.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-4_3e4d066b2a7c7a4d650694dd6743ed01'}\n\n```{.r .cell-code}\nlibrary(r4pde)\noruns.test(row1$y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$U\n[1] 7\n\n$EU\n[1] 10.6\n\n$Z\n[1] -1.727008\n\n$pvalue\n[1] 0.08416615\n\n$result\n[1] \"clustering\"\n```\n:::\n:::\n\n\n\n#### Doublets\n\nDoublet analysis is used to compare the observed number or adjacent diseased plants, a doublet (DD or 11), to the number expected if the disease were randomly distributed in the field. If the observed number is greater than the expected number, contagion within the field is suspected.\n\n![Example for the computation of the number of doublets (DD) in a sequence of binary data](imgs/doublets.png){#fig-doublet1 fig-align=\"center\" width=\"385\"}\n\nThe `doublets.test()` function of the *r4pde* package calculates the doublets and associated statistics.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-5_557c0b3d410ad5a25617274e6bbb0955'}\n\n```{.r .cell-code}\ndoublets.test(row1$y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Db\n[1] 4\n\n$EDb\n[1] 2.8\n\n$ZDb\n[1] 0.7559289\n\n$pvalue\n[1] 0.4496918\n\n$result\n[1] \"randomness\"\n```\n:::\n:::\n\n\n\n#### Foci analysis\n\nThe Analysis of Foci Structure and Dynamics (AFSD), introduced by [@nelson1996simple] and further expanded by [@laranjeira1998dinamica], was used in several studies on citrus diseases in Brazil. In this analysis, the data come from incidence maps where both the diseased and no-diseased trees are mapped in the 2D plane [@jesusjunior2004; @laranjeira2004].\n\nHere is an example of an incidence map with four foci (adapted from [@laranjeira1998dinamica]). The data is organized in the wide format where the first column x is the index for the row and each column is the position of the plant within the row. The 0 and 1 represent the non-diseased and diseased plant, respectively.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-6_7568c271063859e16c02567e8fd66a22'}\n\n```{.r .cell-code}\nfoci <- tibble::tribble(\n           ~x, ~`1`, ~`2`, ~`3`, ~`4`, ~`5`, ~`6`, ~`7`, ~`8`, ~`9`,\n           1,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n           2,   1,   1,   1,   0,   0,   0,   0,   1,   0,\n           3,   1,   1,   1,   0,   0,   0,   1,   1,   1,\n           4,   0,   1,   1,   0,   0,   0,   0,   1,   0,\n           5,   0,   1,   1,   0,   0,   0,   0,   0,   0,\n           6,   0,   0,   0,   1,   0,   0,   0,   0,   0,\n           7,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n           8,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n           9,   0,   0,   0,   0,   0,   1,   0,   1,   0,\n          10,   0,   0,   0,   0,   0,   0,   1,   0,   0,\n          11,   0,   1,   0,   0,   0,   1,   0,   1,   0,\n          12,   0,   0,   0,   0,   0,   0,   0,   0,   0\n          )\n```\n:::\n\n\n\nSince the data frame is in the wide format, we need to reshape it to the long format using `pivot_longer` function of the *tidyr* package before plotting using *ggplot2* package.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-7_ec1eca4eecd84bbbb12cca3ed40b30d7'}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\nfoci2 <- foci |> \n  pivot_longer(2:10, names_to = \"y\", values_to = \"i\")\nfoci2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 108 x 3\n       x y         i\n   <dbl> <chr> <dbl>\n 1     1 1         0\n 2     1 2         0\n 3     1 3         0\n 4     1 4         0\n 5     1 5         0\n 6     1 6         0\n 7     1 7         0\n 8     1 8         0\n 9     1 9         0\n10     2 1         1\n# i 98 more rows\n```\n:::\n:::\n\n\n\nNow we can make the plot.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-foci1_410306bd3c03ce4369601404a81e3431'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nfoci2 |> \n  ggplot(aes(x, y, fill = factor(i)))+\n  geom_tile(color = \"black\")+\n  scale_fill_manual(values = c(\"grey96\", \"grey20\"))+\n  theme_void()+\n  coord_fixed()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Examples of foci of plant diseases - see text for description](spatial-tests_files/figure-pdf/fig-foci1-1.pdf){#fig-foci1 fig-pos='H'}\n:::\n:::\n\n\n\nIn the above plot, the upper left focus is composed of four diseased plants with a pattern of vertical and horizontal proximity to the central unit (or the Rook's case). The upper right focus, also with four diseased plants denotes a pattern of longitudinal proximity to the central unit (or the Bishop's case). The lower left focus is composed of 11 diseased plants with 4 rows and 6 columns occupied by the focus; the shape index of the focus (SIF) is 1.25 and the compactness index of the focus (CIF) is 0.55. The lower right is a single-unit focus.\n\nIn this analysis, several statistics can be summarized, both at the single focus and averaging across all foci in the area, including:\n\n-   Number of foci (NF) and number of single focus (NSF)\n\n-   To compare maps with different number of plants, NF and NSF can be normalized to 1000 plants as NF1000 and NSF1000\n\n-   Number of plants in each focus i (NPFi)\n\n-   Maximum number of rows of the focus i (rfi) and maximum number of columns of the focus i (cfi)\n\n-   Mean shape index of foci (meanSIF = \\[∑(fri / cfi)\\]/NF), where SIF values equal to 1.0 indicate isodiametrical foci; values greater than 1.0 indicate foci with greater length in the direction between the planting rows and values less than 1 indicate foci with greater length in the direction of the planting row.\n\n-   Mean compactness index of foci (meanCIF = \\[∑(NPFi/rfi\\*cfi)\\]/NF), where CIF values close to 1.0 indicate a more compact foci, that is, greater aggregation and proximity among all the plants belonging to the focus\n\nWe can obtain the above-mentioned foci statistics using the `AFSD` function of the *r4pde* package. Let's calculate for the foci2 dataset already loaded, but first we need to check whether all variables are numeric or integer.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-9_a57b306d8e3085c914670f334a9bb563'}\n\n```{.r .cell-code}\nstr(foci2) # y was not numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [108 x 3] (S3: tbl_df/tbl/data.frame)\n $ x: num [1:108] 1 1 1 1 1 1 1 1 1 2 ...\n $ y: chr [1:108] \"1\" \"2\" \"3\" \"4\" ...\n $ i: num [1:108] 0 0 0 0 0 0 0 0 0 1 ...\n```\n:::\n\n```{.r .cell-code}\nfoci2$y <- as.integer(foci2$y) # transform to numeric\n\nlibrary(r4pde)\nresult_foci <- AFSD(foci2)\n```\n:::\n\n\n\nThe AFSD function returns a list of three data frames. The first is a summary statistics of this analysis, together with the disease incidence (DIS_INC), for the data frame in analysis.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-10_48c69f075e7b34814f485ad9706c3f3f'}\n\n```{.r .cell-code}\nknitr::kable(result_foci[[1]])\n```\n\n::: {.cell-output-display}\n|stats    |      value|\n|:--------|----------:|\n|NF       |  4.0000000|\n|NF1000   | 37.0370370|\n|NSF      |  1.0000000|\n|NSF1000  |  9.2592593|\n|DIS_INC  |  0.2037037|\n|mean_SIF |  1.0625000|\n|mean_CIF |  0.6652778|\n:::\n:::\n\n\n\nThe second object in the list is a data frame with statistics at the focus level, including the number of rows and columns occupied by each focus as well as the two indices for each focus: shape and compactness.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-11_36dffb93449a7b6587ceed81b663f3ff'}\n\n```{.r .cell-code}\nknitr::kable(result_foci[[2]])\n```\n\n::: {.cell-output-display}\n|focus_id | size| rows| cols| SIF|       CIF|\n|:--------|----:|----:|----:|---:|---------:|\n|1        |   11|    4|    5| 0.8| 0.5500000|\n|2        |    5|    3|    3| 1.0| 0.5555556|\n|3        |    5|    3|    3| 1.0| 0.5555556|\n|4        |    1|    1|    1| 1.0| 1.0000000|\n:::\n:::\n\n\n\nThe third object is the original data frame amended with the id for each focus which can be plotted and labelled (the focus ID) using the `plot_AFSD()` function.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-12_e4f8a374356e77bbfdad74cdcd6fd779'}\n\n```{.r .cell-code}\nfoci_data <- result_foci[[3]]\nDT::datatable(foci_data)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-3dfc0d2be1f18a08d8ba\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-3dfc0d2be1f18a08d8ba\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\"],[2,2,2,2,3,3,3,3,3,3,4,4,4,5,5,6,9,9,10,11,11,11],[1,2,3,8,1,2,3,7,8,9,2,3,8,2,3,4,6,8,7,2,6,8],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,2,1,1,1,2,2,2,1,1,2,1,1,1,3,3,3,4,3,3]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>x<\\/th>\\n      <th>y<\\/th>\\n      <th>i<\\/th>\\n      <th>focus_id<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,3,4]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n\nThe plot shows the ID for each focus.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-13_6da432bc2e4f25dc1436c01dd72fdc89'}\n\n```{.r .cell-code}\nplot_AFSD(foci_data)+\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nWe will now analyse an actual data set from the *epiphy* package. The data describe the incidence of tomato spotted wilt virus (TSWV) disease in field trials. There are two years in the dataset. We will work with the data from 1928 when 6 assessments were made in time. We will first work with time 1 by using `filter()` function of the *dplyr* package.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-14_9787fc7a1ebc459fdd681f883d862615'}\n\n```{.r .cell-code}\nlibrary(epiphy)\ntswv_1928 <- tomato_tswv$field_1928\ndf1 <- tswv_1928 |>\n  filter(t == 1) |> # filter time 1\n  select(x, y, i) # select only three variables\n```\n:::\n\n\n\nFollows the incidence map of the area at time 1.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-15_90d3fbc2453ef718a0a5e9e8cdb2fed5'}\n\n```{.r .cell-code}\ndf1 |> \n  ggplot(aes(x, y, fill = factor(i)))+\n  geom_tile(color = \"black\")+\n  theme_void()+\n  scale_fill_grey(start = 0.8, end = 0.2)+\n  coord_fixed()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nNow we can run the AFSD function and obtain the statistics.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-16_d5a7a6c3a28e37d655e83d9cba036050'}\n\n```{.r .cell-code}\nresult_df1 <- AFSD(df1)\n\nknitr::kable(result_df1[[1]])\n```\n\n::: {.cell-output-display}\n|stats    |      value|\n|:--------|----------:|\n|NF       | 33.0000000|\n|NF1000   | 17.8571429|\n|NSF      |  8.0000000|\n|NSF1000  |  4.3290043|\n|DIS_INC  |  0.0784632|\n|mean_SIF |  1.1482323|\n|mean_CIF |  0.7977633|\n:::\n:::\n\n\n\nThis analysis is usually applied to multiple maps and the statistics are visually related to the incidence in the area in a scatter plot. Let's calculate the statistics for all five times of the data frame where we will keep now the time variable in the dataframe and split it by time before applying the function. We can do it using the `map` function of the *purrr* package.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-17_7216474689a2e4ecfab7a546983aca5f'}\n\n```{.r .cell-code}\nlibrary(purrr)\n\ndf_all <- tomato_tswv$field_1928\n\n# Split the dataframe by 'time'\ndf_split <- split(df_all, df_all$t)\n\n# Apply the AFSD function to each split dataframe\nresults <- map(df_split, AFSD)\n```\n:::\n\n\n\nWe can check the summary results for time 2 and time 3.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-18_fc343148d7745a04c5e38200df35a5f0'}\n\n```{.r .cell-code}\ntime2 <- data.frame(results[[2]][1])\nknitr::kable(time2)\n```\n\n::: {.cell-output-display}\n|stats    |     value|\n|:--------|---------:|\n|NF       | 2.0000000|\n|NF1000   | 1.0822511|\n|NSF      | 0.0000000|\n|NSF1000  | 0.0000000|\n|DIS_INC  | 0.2364719|\n|mean_SIF | 1.7121212|\n|mean_CIF | 1.1352814|\n:::\n\n```{.r .cell-code}\ntime3 <- data.frame(results[[3]][1])\nknitr::kable(time3)\n```\n\n::: {.cell-output-display}\n|stats    |     value|\n|:--------|---------:|\n|NF       | 1.0000000|\n|NF1000   | 0.5411255|\n|NSF      | 0.0000000|\n|NSF1000  | 0.0000000|\n|DIS_INC  | 0.4085498|\n|mean_SIF | 0.4242424|\n|mean_CIF | 1.6341991|\n:::\n\n```{.r .cell-code}\n# Plot the results to see the two foci in time 1\nplot_AFSD(results[[1]][[3]])+\n  theme_void()+\n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Plot time 2\nplot_AFSD(results[[2]][[3]])+\n  theme_void()+\n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-18-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n#### Join count\n\nIn this analysis, two adjacent plants may be classified by the type of join that links them: D-D, H-H or H-D. The orientation(s) of interest (along rows, across rows, diagonally, or a a combination o these) should be specified in the test. The number of joins of the specified type in the orientation(s) of interest is then counted. The question is whether the observed join-count is large (or small) relative to that expected for a random pattern. The join-count statistics provides a basic measure of spatial autocorrelation.\n\nIn R, we can use the `join.count()` function of the *spdep* package to perform a joint count test. First, we need to create the series of binary data from top to bottom and left to right. The data are shown in Fig. 9.13 in page 260 of the book chapter on spatial analysis [@chapter2017]. In the example, there are 5 rows and 5 columns. This will be informed later to run the test.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-19_94d58c70ca10d848869b707efcbf494b'}\n\n```{.r .cell-code}\nS2 <- c(1,0,1,1,0,\n       1,1,0,0,0,\n       1,0,1,0,0,\n       1,0,0,1,0,\n       0,1,0,1,1)\n```\n:::\n\n\n\nVisualize the two-dimensional array:\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-joincount1_f0478dd3c132b2ed10c827fe3e9a1737'}\n\n```{.r .cell-code}\n# Convert to raster \nmapS2 <- terra::rast(matrix(S2, 5 , 5))\n# Convert to data frame\nmapS3 <- terra::as.data.frame(mapS2, xy = TRUE)\nmapS3 |>\n  ggplot(aes(x, y, label = lyr.1, fill = factor(lyr.1))) +\n  geom_tile(color = \"white\", size = 0.5) +\n  theme_void() +\n  labs(fill = \"Status\") +\n  scale_fill_manual(values = c(\"gray70\", \"darkred\"))+\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\ni Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![Visualization of a matrix of presence or absence data representing a disease spatial pattern](spatial-tests_files/figure-pdf/fig-joincount1-1.pdf){#fig-joincount1 fig-pos='H'}\n:::\n:::\n\n\n\nAfter loading the library, we need to generate a list of neighbors (nb) for a grid of cells. This is performed with the `cell2nb()` function by informing the number of rows and columns. The argument `rook` means shared edge, but it could be the `queen`, for shared edge or vertex. We can use the default.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-21_73894f2560c51ffb99969515fe1a328c'}\n\n```{.r .cell-code}\nlibrary(spdep)\nnb <- cell2nb(nrow = 5,\n              ncol = 5,\n              type = \"rook\")\n```\n:::\n\n\n\nThe `joincount.test()` function runs the BB join count test for spatial autocorrelation. The method uses a spatial weights matrix in weights list form for testing whether same-status joins occur more frequently than would be expected if the zones were labelled in a spatially random way. We need to inform the sequence as factor and the `nb` object we created previously.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-22_5823bb6660b8d1c9b6b323cf5d4080eb'}\n\n```{.r .cell-code}\njoincount.test(factor(S2), \n                nb2listw(nb))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S2) \nweights: nb2listw(nb) \n\nStd. deviate for 0 = -0.58266, p-value = 0.7199\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            2.9583333             3.2500000             0.2505797 \n\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S2) \nweights: nb2listw(nb) \n\nStd. deviate for 1 = -0.66841, p-value = 0.7481\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            2.4166667             2.7500000             0.2486957 \n```\n:::\n:::\n\n\n\nThe function returns a list with a class for each of the status (in this case 0 and 1) with several components. We should look at the *P-value*. The alternative hypothesis (greater) is that the same status joins occur more frequently than expected if they were labelled in a spatial random way. In this case, we do not reject the null hypothesis of randomness.\n\nWe can run the ordinary runs and doublets tests, which only considers the adjacent neighbor, for the same series and compare the results.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-23_ad2aef79fddba23df3fa807e85c13f0c'}\n\n```{.r .cell-code}\noruns.test(S2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$U\n[1] 17\n\n$EU\n[1] 13.48\n\n$Z\n[1] 1.440688\n\n$pvalue\n[1] 0.1496727\n\n$result\n[1] \"clustering\"\n```\n:::\n\n```{.r .cell-code}\ndoublets.test(S2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Db\n[1] 3\n\n$EDb\n[1] 5.28\n\n$ZDb\n[1] -1.034484\n\n$pvalue\n[1] 0.3009097\n\n$result\n[1] \"randomness\"\n```\n:::\n:::\n\n\n\nLet's repeat the procedure using the second array of data shown in the book chapter, for which the result is different. In this case, there is evidence to reject the null hypothesis, indicating aggregation of plants.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-24_f72f4a20aa54ca3c632643e4e323590d'}\n\n```{.r .cell-code}\nS3 <- c(1,1,1,0,0,\n       1,1,1,0,0,\n       1,1,1,0,0,\n       1,1,1,0,0,\n       0,0,0,0,0)\n\njoincount.test(factor(S3), \n                nb2listw(nb))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S3) \nweights: nb2listw(nb) \n\nStd. deviate for 0 = 4.2451, p-value = 1.093e-05\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            5.3750000             3.2500000             0.2505797 \n\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S3) \nweights: nb2listw(nb) \n\nStd. deviate for 1 = 4.5953, p-value = 2.16e-06\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            5.0416667             2.7500000             0.2486957 \n```\n:::\n\n```{.r .cell-code}\noruns.test(S3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$U\n[1] 8\n\n$EU\n[1] 13.48\n\n$Z\n[1] -2.24289\n\n$pvalue\n[1] 0.02490392\n\n$result\n[1] \"clustering\"\n```\n:::\n:::\n\n\n\nWe can apply these tests for a real example epidemic data provided by the [epiphy](https://chgigot.github.io/epiphy/) R package [@gigot2018]. Let's work with part of the intensively mapped data on the incidence of tomato spotted wilt virus (TSWV) disease in field trials reported by Cochran (1936) and Bald (1937). First, we need to load the library and then assign one dataframe (the dataset has two dataframes) of the dataset `tomato_tswv` to a new dataframe called `tswv_1929`.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-25_4a0d4c3b38fd0b721ecf1d7b5907610a'}\n\n```{.r .cell-code}\nlibrary(epiphy)\ntswv_1929 <- tomato_tswv$field_1929\ntswv_1929 |>  head(10) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x  y t i n\n1  1  1 1 0 1\n2  1  2 1 1 1\n3  1  3 1 0 1\n4  1  4 1 1 1\n5  1  5 1 0 1\n6  1  6 1 0 1\n7  1  7 1 0 1\n8  1  8 1 0 1\n9  1  9 1 1 1\n10 1 10 1 0 1\n```\n:::\n:::\n\n\n\nThe inspection of the first 10 rows of the dataframe shows five variables where x and y are spatial grid coordinates, t is assessment time, i is the status of the plant (0 = healthy, 1 = diseased) and n is the sampling unit size (here all one). Let's visualize these data for each sampling time.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-tsw_62367e4fc88efb7d3dcaf183d1f576e9'}\n\n```{.r .cell-code}\ntswv_1929 |>\n  ggplot(aes(x, y, fill = factor(i))) +\n  geom_tile() +\n  coord_fixed() +\n  scale_fill_manual(values = c(\"gray70\", \"darkred\")) +\n  facet_wrap( ~ t) +\n  labs(fill = \"Status\")+\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![Incidence maps for for tomato spotted wilt virus (TSWV) disease in field trials reported by Cochran (1936) and Bald (1937)](spatial-tests_files/figure-pdf/fig-tsw-1.pdf){#fig-tsw fig-pos='H'}\n:::\n:::\n\n\n\nCheck the number of rows (y) and columns (x) for further preparing the neighbor object for the join count statistics.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-27_63a688beb6aa0c235a16831fb9856916'}\n\n```{.r .cell-code}\ntswv_1929 |> \n  dplyr::select(x, y) |> \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       x               y        \n Min.   : 1.00   Min.   : 1.00  \n 1st Qu.: 6.75   1st Qu.:15.75  \n Median :12.50   Median :30.50  \n Mean   :12.50   Mean   :30.50  \n 3rd Qu.:18.25   3rd Qu.:45.25  \n Max.   :24.00   Max.   :60.00  \n```\n:::\n:::\n\n\n\nThere are 60 rows and 24 columns.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-28_a0a636aef724d117bfd2b4cd9f1c3602'}\n\n```{.r .cell-code}\n# Neighbor grid\nnb1 <- cell2nb(nrow = 60,\n               ncol = 24,\n               type = \"rook\")\n\n# Pull the binary sequence of time 1\nS1 <- tswv_1929 |>\n  filter(t == \"1\") |>\n  pull(i)\n\njoincount.test(factor(S1),\n               nb2listw(nb1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S1) \nweights: nb2listw(nb1) \n\nStd. deviate for 0 = -0.28351, p-value = 0.6116\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n           482.000000            482.578874              4.169132 \n\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S1) \nweights: nb2listw(nb1) \n\nStd. deviate for 1 = -0.059497, p-value = 0.5237\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            23.458333             23.578874              4.104614 \n```\n:::\n:::\n\n\n\nWe can apply the join count test for time 2 and time 3. Results show that the pattern changes from random to aggregate over time.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-29_15993f7372ad204ba9551bd4d882ee8f'}\n\n```{.r .cell-code}\n# Pull the binary sequence of time 1\nS2 <- tswv_1929 |>\n  filter(t == \"2\") |>\n  pull(i)\n\njoincount.test(factor(S2),\n               nb2listw(nb1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S2) \nweights: nb2listw(nb1) \n\nStd. deviate for 0 = 0.35872, p-value = 0.3599\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n           317.000000            315.900625              9.392312 \n\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S2) \nweights: nb2listw(nb1) \n\nStd. deviate for 1 = 0.34604, p-value = 0.3647\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            82.958333             81.900625              9.342754 \n```\n:::\n\n```{.r .cell-code}\n# Pull the binary sequence of time 1\nS3 <- tswv_1929 |>\n  filter(t == \"3\") |>\n  pull(i)\n\njoincount.test(factor(S3), \n                nb2listw(nb1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S3) \nweights: nb2listw(nb1) \n\nStd. deviate for 0 = 1.8541, p-value = 0.03186\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            136.12500             129.92773              11.17243 \n\n\n\tJoin count test under nonfree sampling\n\ndata:  factor(S3) \nweights: nb2listw(nb1) \n\nStd. deviate for 1 = 1.7275, p-value = 0.04204\nalternative hypothesis: greater\nsample estimates:\nSame colour statistic           Expectation              Variance \n            243.70833             237.92773              11.19743 \n```\n:::\n:::\n\n\n\n### Point pattern analysis\n\nPoint pattern analysis involves the study of the spatial arrangement of points in a two-dimensional space. In its simplest form, one can visualize this as a scatterplot on a map, where each point represents an event, object, or entity in space. For example, the points might represent the locations of diseased plants in a population.\n\nThe easiest way to visualize a 2-D point pattern is to produce a map of the locations, which is simply a scatterplot but with the provision that the axes are equally scaled. However, while the visualization can provide a basic understanding of the spatial distribution, the real power of point pattern analysis lies in the quantitative methods that allow one to analyze the distribution in a more detailed and systematic way. These methods help to identify whether the points are randomly distributed, clustered (points are closer together than expected by chance), or regularly spaced (points are more evenly spaced than expected by chance). This analysis can provide insights into underlying processes that might explain the observed patterns.\n\nLet's work with two simulated datasets that were originally generated to produced a random or an aggregated (clustered) pattern.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-30_0f9b87124fea98cabc7148ef431409b6'}\n\n```{.r .cell-code}\nlibrary(r4pde)\nrand <- SpatialRandom\naggr <- SpatialAggregated\n```\n:::\n\n\n\nIn order to create a polygon with the most extreme points, we can use the `chull()` function to find the convex hull, which will give us the indices of the points that form the smallest convex polygon that contains all the points in our dataset.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-31_51927892089d577f68aabea0ab69a95d'}\n\n```{.r .cell-code}\nhull_indices_rand <- chull(rand)\n# Add these indices as a new column to the data frame\nrand$hull <- FALSE\nrand$hull[hull_indices_rand] <- TRUE\n\nhull_indices_aggr <- chull(aggr)\n# Add these indices as a new column to the data frame\naggr$hull <- FALSE\naggr$hull[hull_indices_aggr] <- TRUE\n```\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-32_fa4e91d782081baf01c6a3567ca4bc3b'}\n\n:::\n\n\n\n\nThe two dataframes has two variables each.  Let's produce 2-D map.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-33_b83a010900f39d1dec3b2bbe18209c50'}\n\n```{.r .cell-code}\nprand <- rand |> \n  ggplot(aes(x, y))+\n  geom_polygon(data = rand[hull_indices_rand, ], aes(x, y), fill = NA, color = 'black') +\n  geom_point()+\n  scale_color_manual(values = c(\"black\", NA))+\n  coord_fixed()+\n  coord_flip()+\n  theme_void()+\n  theme(legend.position = \"none\")+\n  labs (title = \"Random spatial pattern\", \n        x = \"Latitude\",\n        y = \"Longitude\",\n        caption = \"Source: r4pd R package\")\n\npaggr <- aggr |> \n  ggplot(aes(x, y))+\n  geom_polygon(data = aggr[hull_indices_aggr, ], aes(x, y), fill = NA, color = 'black') +\n  geom_point()+\n  scale_color_manual(values = c(\"black\", NA))+\n  coord_fixed()+\n  coord_flip()+\n  theme_void()+\n  theme(legend.position = \"none\")+\n  labs (title = \"Aggregated spatial pattern\", \n        x = \"Latitude\",\n        y = \"Longitude\",\n        caption = \"Source: r4pd R package\")\n\nlibrary(patchwork)\nprand | paggr\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-33-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n#### Quadrat based\n\nQuadrat count analysis for random data\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-34_e6a93350c307cf88a33d3558eac35822'}\n\n```{.r .cell-code}\nlibrary(spatstat)\n### Create window \nwindow_rand <- ripras(rand$x, rand$y)\n\n# create the point pattern object\nppp_rand <- ppp(rand$x, rand$y, window_rand)\nplot(ppp_rand)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-34-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Quadrat count 10 x 10\nqq <- quadratcount(ppp_rand,8,8, keepempty=TRUE) \n\n# plot the quadrat count\nplot(qq)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-34-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Quadrat test\nqt <- quadrat.test(qq, alternative=\"clustered\", method=\"M\")\nqt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tConditional Monte Carlo test of CSR using quadrat counts\n\tTest statistic: Pearson X2 statistic\n\ndata:  \nX2 = 48.441, p-value = 0.913\nalternative hypothesis: clustered\n\nQuadrats: 64 tiles (irregular windows)\n```\n:::\n:::\n\n\n\nQuadrat count analysis for aggregated data \n\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-35_638495ffa70a583214203db83cb01828'}\n\n```{.r .cell-code}\n### Create window \nwindow_aggr <- ripras(aggr$x, aggr$y)\n\n# create the point pattern object\nppp_aggr <- ppp(aggr$x, aggr$y, window_aggr)\nplot(ppp_aggr)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-35-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Quadrat count 10 x 10\nqq_aggr <- quadratcount(ppp_aggr,8,8, keepempty=TRUE) \n\n# plot the quadrat count\nplot(qq_aggr)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-35-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Quadrat test\nqt_aggr <- quadrat.test(qq, alternative=\"clustered\", method=\"M\")\nqt_aggr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tConditional Monte Carlo test of CSR using quadrat counts\n\tTest statistic: Pearson X2 statistic\n\ndata:  \nX2 = 48.441, p-value = 0.9135\nalternative hypothesis: clustered\n\nQuadrats: 64 tiles (irregular windows)\n```\n:::\n:::\n\n\n\n\n#### Spatial KS test\n\nPerforms a test of goodness-of-fit test of the uniform Poisson point process (Complete Spatial Randomness, CSR) for the data set. The test is performed by comparing the observed distribution of the values of a spatial covariate at the data points, and the predicted distribution of the same covariate under the model, using a classical goodness-of-fit test @baddeley2005. Thus, we must nominate a spatial covariate for this test. In the case below we nominate x, y or x and y as covariate.\n\nLet's test for the aggregated data.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-36_13a35afb1aea832c3c90d38857373bf6'}\n\n```{.r .cell-code}\n# y as covariate\nks_y <- cdf.test(ppp_aggr, test=\"ks\", \"y\", jitter=FALSE)\nks_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tSpatial Kolmogorov-Smirnov test of CSR in two dimensions\n\ndata:  covariate 'y' evaluated at points of 'ppp_aggr' \n     and transformed to uniform distribution under CSR\nD = 0.075883, p-value = 0.1821\nalternative hypothesis: two-sided\n```\n:::\n\n```{.r .cell-code}\nplot(ks_y)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-36-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# x as covariate\nks_x <- cdf.test(ppp_aggr, test=\"ks\", \"x\", jitter=FALSE)\nks_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tSpatial Kolmogorov-Smirnov test of CSR in two dimensions\n\ndata:  covariate 'x' evaluated at points of 'ppp_aggr' \n     and transformed to uniform distribution under CSR\nD = 0.09506, p-value = 0.04661\nalternative hypothesis: two-sided\n```\n:::\n\n```{.r .cell-code}\nplot(ks_x)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-36-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# x and y as covariates\nfun <- function(x,y){2* x + y}\nks_xy <- cdf.test(ppp_aggr, test=\"ks\", fun, jitter=FALSE)\nks_xy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tSpatial Kolmogorov-Smirnov test of CSR in two dimensions\n\ndata:  covariate 'fun' evaluated at points of 'ppp_aggr' \n     and transformed to uniform distribution under CSR\nD = 0.12026, p-value = 0.004875\nalternative hypothesis: two-sided\n```\n:::\n\n```{.r .cell-code}\nplot(ks_xy)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-36-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAs shown above, we have sufficient evidence to reject the null hypothesis of complete spatial randomness.\n\n#### Distance based\n\nA spatial point process is a set of irregularly distributed locations within a defined region which are assumed to have been generated by some form of stochastic mechanism.\n\nThe **K function**, a.k.a. Ripley's K-function, is a statistical measure used in spatial analysis to examine the spatial distribution of a single type of point in a given area. Named after its developer, the British statistician B.D. Ripley, the K-function measures the expected number of points within a given distance of an arbitrary point, assuming homogeneous intensity (a constant probability of a point occurring in a particular place).\n\nTo describe it simply: imagine you have a map of diseased trees in a forest, and you select a tree at random. The K-function helps you answer the question: \"How many other diseased trees do I expect to find within a certain distance from the diseased tree I've chosen?\"\n\nThe K-function is often used to identify and analyze patterns within spatial data, such as clustering, randomness, or regularity (dispersion). It is particularly useful because it looks at the distribution at all scales (distances) simultaneously. To interpret the results of Ripley's K-function:\n\n1.  **Random distribution**: If the points (like trees in our example) are randomly distributed, the plot of the K-function will be a straight line at a 45-degree angle.\n\n2.  **Clustered distribution**: If the points are clustered (grouped closer together than you'd expect by chance), the plot will be above the 45-degree line of the random expectation.\n\n3.  **Regular or dispersed distribution**: If the points are regularly spaced or dispersed (further apart than you'd expect by chance), the plot will be below the 45-degree line.\n\nRipley's K checks the density of diseased units in each area by the variance as a function of radial distances (*r*) from the diseased unit, hence *K(r)*. If the spatial localization of a diseased unit is independent, the process is random in space.\n\nLet's use the `Kest` function of the spatstat package to obtain *K(r)*.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-37_be3e968ba363c00f1d0b1638d3b8c46d'}\n\n```{.r .cell-code}\nk_rand <- Kest(ppp_rand)\nplot(k_rand)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-37-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nk_aggr <- Kest(ppp_aggr)\nplot(k_aggr)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-37-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nThe `envelope` function performs simulations and computes envelopes of a summary statistic based on the simulations. The envelope can be used to assess the goodness-of-fit of a point process model to point pattern data [@baddeley2014]. Let's simulate the envelope and plot the values using ggplot. Because observed *K(r)* (solid line) lied outside the simulation envelope, aggregation was detected.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-38_033a13a8d5e8a337149f56bb74fe7f4e'}\n\n```{.r .cell-code}\nke <- envelope(ppp_aggr, fun = Kest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGenerating 99 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.\n\nDone.\n```\n:::\n\n```{.r .cell-code}\ndata.frame(ke) |> \n  ggplot(aes(r, theo))+\n  geom_line(linetype =2)+\n  geom_line(aes(r, obs))+\n  geom_ribbon(aes(ymin = lo, ymax = hi),\n              fill = \"steelblue\", alpha = 0.5)+\n  labs(y = \"K(r)\", x = \"r\")+\n  theme_bw(base_size = 16)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-38-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n`mad.test` performs the 'global' or 'Maximum Absolute Deviation' test described by Ripley (1977, 1981). See [@baddeley2014]. This performs hypothesis tests for goodness-of-fit of a point pattern data set to a point process model, based on Monte Carlo simulation from the model.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-39_3d744f1ac5380471a1f4524ba7d83c28'}\n\n```{.r .cell-code}\n# Maximum absolute deviation test\nmad.test(ppp_aggr, Kest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGenerating 99 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.\n\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMaximum absolute deviation test of CSR\n\tMonte Carlo test based on 99 simulations\n\tSummary function: K(r)\n\tReference function: theoretical\n\tAlternative: two.sided\n\tInterval of distance values: [0, 50.8401070056579]\n\tTest statistic: Maximum absolute deviation\n\tDeviation = observed minus theoretical\n\ndata:  ppp_aggr\nmad = 1765.1, rank = 1, p-value = 0.01\n```\n:::\n\n```{.r .cell-code}\nmad.test(ppp_rand, Kest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGenerating 99 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,  99.\n\nDone.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMaximum absolute deviation test of CSR\n\tMonte Carlo test based on 99 simulations\n\tSummary function: K(r)\n\tReference function: theoretical\n\tAlternative: two.sided\n\tInterval of distance values: [0, 45.9916850622588]\n\tTest statistic: Maximum absolute deviation\n\tDeviation = observed minus theoretical\n\ndata:  ppp_rand\nmad = 122.15, rank = 82, p-value = 0.82\n```\n:::\n:::\n\n\n\nAnother statistics that can be used is the **O-ring** statitics which are used in spatial analysis to quantify and test the degree of interaction between two types of spatial points [@wiegand2004]. The name derives from the method of placing a series of concentric circles (O-rings) around each point of type 1 and counting how many points of type 2 fall within each ring. The plot generated by O-ring statistics is called an O-ring plot or an O-function plot. It plots the radius of the rings on the x-axis and the estimated intensity of points of type 2 around points of type 1 on the y-axis.\n\nInterpreting the plot is as follows:\n\n1.  **Random pattern**: If points of type 2 are randomly distributed around points of type 1, the O-ring plot will be a flat line. This means that the intensity of points of type 2 does not change with the distance to points of type 1.\n\n2.  **Aggregation or clustering**: If points of type 2 are aggregated around points of type 1, the O-ring plot will be an upward-sloping curve. This indicates that the intensity of points of type 2 increases with proximity to points of type 1.\n\n3.  **Dispersion**: If points of type 2 are dispersed away from points of type 1, the O-ring plot will be a downward-sloping curve. This shows that the intensity of points of type 2 decreases as you get closer to points of type 1.\n\nThe O-ring plot often includes a confidence envelope. If the O-ring statistic falls within this envelope, it suggests that the observed pattern could be the result of random spatial processes. If it falls outside the envelope, it suggests that the pattern is not random. Therefore, to decide whether a pattern is aggregated or random using O-ring statistics:\n\n-   Look at the shape of the O-ring plot.\n\n-   Compare the O-ring statistic to the confidence envelope.\n\nAn aggregated pattern will show an increasing curve that lies outside the confidence envelope, indicating that the density of type 2 points is higher close to type 1 points. On the other hand, a random pattern will show a flat line that lies within the confidence envelope, indicating no significant difference in the density of type 2 points around type 1 points at varying distances.\n\nIn R, we can use the `estimate_o_ring()` function of the *onpoint* package. We will use the point pattern object `ppp_fw` used in the previous examples\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-40_f904e4bfbe0e471906e7e0a16a3cff62'}\n\n```{.r .cell-code}\nlibrary(onpoint)\nplot(estimate_o_ring(ppp_rand))\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-40-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\nplot(estimate_o_ring(ppp_aggr))\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-40-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nThe function can be used in combination with `spatstat`'s `envelope()` function.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-41_dc19d6f7d30bdd29b8fb381c514b0484'}\n\n```{.r .cell-code}\noring_envelope <- envelope(ppp_aggr, fun = estimate_o_ring, nsim = 199, verbose = FALSE)\nplot(oring_envelope)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-41-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nTo plot simulation envelopes using quantum plots [@esser2014], just pass an `envelope` object as input to [`plot_quantums()`](https://r-spatialecology.github.io/onpoint/reference/plot_quantums.html).\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-42_a1bef46ece23ca97d82df015407dfb10'}\n\n```{.r .cell-code}\nplot_quantums(oring_envelope, ylab = \"O-ring\")\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-42-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n### Grouped data\n\nIf the data are intensively mapped, meaning that the spatial locations of the sampling units are known, we are not limited to analyse presence/absence (incidence) only data at the unit level. The sampling units may be quadrats where the total number of plants and the number of disease plants (or number of pathogen propagules) are known. Alternatively, it could be a continuous measure of severity. The question here, similar to the previous section, is whether a plant being diseased makes it more (or less) likely that neighboring plants will be diseased. If that is the case, diseased plants are exhibiting spatial autocorrelation. The most common methods are autocorrelation (known as Moran's I), semivariance and SADIE (an alternative approach to autocorrelation.)\n\n#### Autocorrelation\n\nSpatial autocorrelation analysis provides a quantitative assessment of whether a large value of disease intensity in a sampling unit makes it more (positive autocorrelation) or less (negative auto- correlation) likely that neighboring sampling units tend to have a large value of disease intensity [@chapter2017].\n\nWe will illustrate the method by reproducing the example provided in page 264 of the chapter on spatial analysis [@chapter2017], which was extracted from table 11.3 of @Campbell1990. The data represent a single transect with the number of *Macrophomia phaseolina* propagules per 10 g air-dry soil recorded in 16 contiguous quadrats across a field.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-43_35ffa7665f452dc8835b772836a8b3a7'}\n\n```{.r .cell-code}\nmp <- data.frame(\n  i = c(1:16),\n  y = c(41, 60, 81, 22, 8, 20, 28, 2, 0, 2, 2, 8, 0, 43, 61, 50)\n)\nmp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    i  y\n1   1 41\n2   2 60\n3   3 81\n4   4 22\n5   5  8\n6   6 20\n7   7 28\n8   8  2\n9   9  0\n10 10  2\n11 11  2\n12 12  8\n13 13  0\n14 14 43\n15 15 61\n16 16 50\n```\n:::\n:::\n\n\n\nWe can produce a plot to visualize the number of propagules across the transect.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-macrophomina_221b230daae02ed9f2d1f53e789527e2'}\n\n```{.r .cell-code}\nmp |>\n  ggplot(aes(i, y)) +\n  geom_col(fill = \"darkred\") +\n  labs(\n    x = \"Relative position within a transect\",\n    y = \"Number of propagules\",\n    caption = \"Source: Campbell and Madden (1990)\"\n  )\n```\n\n::: {.cell-output-display}\n![Number of propagules of Macrophomina phaseolina in the soil at various positions within a transect](spatial-tests_files/figure-pdf/fig-macrophomina-1.pdf){#fig-macrophomina fig-pos='H'}\n:::\n:::\n\n\n\nTo calculate the autocorrelation coefficient in R, we can use the `ac()` function of the *tseries* package.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-45_f6130a202cea41e3171372e796ffa16e'}\n\n```{.r .cell-code}\nlibrary(tseries)\nac_mp <- acf(mp$y, lag = 5, pl = FALSE)\nac_mp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nAutocorrelations of series 'mp$y', by lag\n\n     0      1      2      3      4      5 \n 1.000  0.586  0.126 -0.033 -0.017 -0.181 \n```\n:::\n:::\n\n\n\nLet's store the results in a data frame to facilitate visualization.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-46_741196fe7b1a63fa86eff8b04c0838fd'}\n\n```{.r .cell-code}\nac_mp_dat <- data.frame(index = ac_mp$lag, ac_mp$acf)\nac_mp_dat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  index   ac_mp.acf\n1     0  1.00000000\n2     1  0.58579374\n3     2  0.12636306\n4     3 -0.03307249\n5     4 -0.01701392\n6     5 -0.18092810\n```\n:::\n:::\n\n\n\nAnd now the plot known as autocorrelogram.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-autocorrel_ab43667d1caf503465d9d05cf3511b6f'}\n\n```{.r .cell-code}\nac_mp_dat |>\n  ggplot(aes(index, ac_mp.acf, label = round(ac_mp.acf, 3))) +\n  geom_col(fill = \"darkred\") +\n  geom_text(vjust = 0, nudge_y = 0.05) +\n  scale_x_continuous(n.breaks = 6) +\n  geom_hline(yintercept = 0) +\n  labs(x = \"Distance lag\", y = \"Autocorrelation coefficient\")\n```\n\n::: {.cell-output-display}\n![Autocorrelogram for the spatial distribution of Macrophomina phaseolina in soil](spatial-tests_files/figure-pdf/fig-autocorrel-1.pdf){#fig-autocorrel fig-pos='H'}\n:::\n:::\n\n\n\nThe values we obtained here are not the same but quite close to the values reported in @madden2017. For the transect data, the calculated coefficients in the book example for lags 1, 2 and 3 are 0.625, 0.144, and - 0.041. The conclusion is the same, the smaller the distance between sampling units, the stronger is the correlation between the count values.\n\nThe method above is usually referred to Moran's I [@Moran1950]. Let's use another example dataset from the book to calculate the Moran's I in R. The data is shown in page 269 of the book. The data represent the number of diseased plants per quadrat (out of a total of 100 plants in each) in 144 quadrats. It was based on an epidemic generated using the stochastic simulator of @xu2004. The data is stored in a CSV file.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-48_6addfdaa95f6563738b86328051531a7'}\n\n```{.r .cell-code}\nepi <- read_csv(\"https://raw.githubusercontent.com/emdelponte/epidemiology-R/main/data/xu-madden-simulated.csv\")\nepi1 <- epi |>\n  pivot_longer(2:13,\n               names_to = \"y\",\n               values_to = \"n\") |>\n  pull(n)\n```\n:::\n\n\n\nUsing `moran()` function of the *spdep* R package.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-49_167ece27cf739e8710f63067c4d1972c'}\n\n```{.r .cell-code}\nset.seed(100)\nlibrary(spdep)\n```\n:::\n\n\n\nThe `cell2nb()` function creates the neighbor list with 12 rows and 12 columns, which is how the 144 quadrats are arranged.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-50_57b8179cb4b672ed736d548eda4084d1'}\n\n```{.r .cell-code}\nnb <- cell2nb(12, 12, type = \"queen\", torus = FALSE)\n```\n:::\n\n\n\nThe `nb2listw()` function supplements a neighbors list with spatial weights for the chosen coding scheme. We use the default W, which is the row standardized (sums over all links to n). We then create the `col.W` neighbor list.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-51_8fca105bd9ba31eaee9196df6d9be099'}\n\n```{.r .cell-code}\ncol.W <- nb2listw(nb, style = \"W\")\n```\n:::\n\n\n\nThe Moran's I statistic is given by the `moran()` function\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-52_6e7cb93a1d0ca76c1e51bf047d1eb01a'}\n\n```{.r .cell-code}\nmoran(x = epi1, # numeric vector\n      listw = col.W, # the nb list\n      n = 12, # number of zones\n      S0 = Szero(col.W)) # global sum of weights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$I\n[1] 0.05818595\n\n$K\n[1] 2.878088\n```\n:::\n:::\n\n\n\nThe Moran's test for spatial autocorrelation uses spatial weights matrix in weights list form.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-53_3199790ab6c8fe725dc462e3c1387246'}\n\n```{.r .cell-code}\nmoran.test(x = epi1, \n           listw = col.W)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  epi1  \nweights: col.W    \n\nMoran I statistic standard deviate = 15.919, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.698231416      -0.006993007       0.001962596 \n```\n:::\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-54_013650c0d38d30bfc069c0d52f594059'}\n\n```{.r .cell-code}\ncorrel_I <- sp.correlogram(nb, epi1, \n                           order = 10,\n                           method = \"I\",  \n                           zero.policy = TRUE)\n```\n:::\n\n\n\nWe can generate a correlogram using the output of the `sp.correlogram()` function. Note that the figure below is very similar to the one shown in Figure 91.5 in page 269 of the book chapter [@chapter2017]. Let's store the results in a dataframe.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-55_22b1c184440ed0ab13b5faeb37f8ef44'}\n\n```{.r .cell-code}\ndf_correl <- data.frame(correl_I$res) |> \n  mutate(lag = c(1:10))\n\n# Show the spatial autocorrelation for 10 distance lags\nround(df_correl$X1,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.698  0.340  0.086 -0.002 -0.009 -0.024 -0.090 -0.180 -0.217 -0.124\n```\n:::\n:::\n\n\n\nThen, we can generate the plot using *ggplot*.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-autocorrel2_698a56e82ac9c70ef09615a74c516db1'}\n\n```{.r .cell-code}\ndf_correl |>\n  ggplot(aes(lag, X1)) +\n  geom_col(fill = \"darkred\") +\n  scale_x_continuous(n.breaks = 10) +\n  labs(x = \"Distance lag\", y = \"Spatial autocorrelation\")\n```\n\n::: {.cell-output-display}\n![Autocorrelogram for the spatial distribution of simulated epidemics](spatial-tests_files/figure-pdf/fig-autocorrel2-1.pdf){#fig-autocorrel2 fig-pos='H'}\n:::\n:::\n\n\n\n#### Semivariance\n\nSemi-variance is a key quantity in geostatistics. This differs from spatial autocorrelation because distances are usually measured in discrete spatial lags. The semi-variance can be defined as half the variance of the differences between all possible points spaced a constant distance apart.\n\nThe semi-variance at a distance d = 0 will be zero, because there are no differences between points that are compared to themselves. However, as points are compared to increasingly distant points, the semi-variance increases. At some distance, called the *Range*, the semi-variance will become approximately equal to the variance of the whole surface itself. This is the greatest distance over which the value at a point on the surface is related to the value at another point. In fact, when the distance between two sampling units is small, the sampling units are close together and, usually, variability is low. As the distance increases, so (usually) does the variability.\n\nResults of semi-variance analysis are normally presented as a graphical plot of semi-variance against distance, which is referred to as a semi-variogram. The main characteristics of the semi-variogram of interest are the nugget, the range and the sill, and their estimations are usually based on an appropriate (non-linear) model fitted to the data points representing the semi-variogram.\n\nFor the semi-variance, we will use the `variog()` function of the *geoR* package. We need the data in the long format (x, y and z). Let's reshape the data to the long format and store it in `epi2` dataframe.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-57_1f4fced2c950d17ace0b3a536992c0ea'}\n\n```{.r .cell-code}\nepi2 <- epi |>\n  pivot_longer(2:13,\n               names_to = \"y\",\n               values_to = \"n\") |>\n  mutate(y = as.numeric(y))\n\nhead(epi2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n      x     y     n\n  <dbl> <dbl> <dbl>\n1     1     1     2\n2     1     2     2\n3     1     3     3\n4     1     4    33\n5     1     5     4\n6     1     6     0\n```\n:::\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-58_6f0412fedac7b0db4c88d2677865f1d3'}\n\n```{.r .cell-code}\nlibrary(geoR)\n# the coordinates are x and y and the data is the n\nv1 <- variog(coords = epi2[,1:2], data = epi2[,3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvariog: computing omnidirectional variogram\n```\n:::\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-semivariance_f128b12409ebf8c81416518534d91f59'}\n\n```{.r .cell-code}\nv2 <- variofit(v1, ini.cov.pars = c(1200, 12), \n               cov.model = \"exponential\", \n               fix.nugget = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvariofit: covariance model used is exponential \nvariofit: weights used: npairs \nvariofit: minimisation function used: optim \n```\n:::\n\n```{.r .cell-code}\n# Plotting \nplot(v1, xlim = c(0,15))\nlines(v2, lty = 1, lwd = 2)\n```\n\n::: {.cell-output-display}\n![Semivariance plot for the spatial distribution simulated epidemic](spatial-tests_files/figure-pdf/fig-semivariance-1.pdf){#fig-semivariance fig-pos='H'}\n:::\n:::\n\n\n\n#### SADIE\n\nSADIE (spatial analysis by distance indices) is an alternative to autocorrelation and semi-variance methods described previously, which has found use in plant pathology [@chapter2017; @xu2004; @li2011]. Similar to those methods, the spatial coordinates for the disease intensity (count of diseased individuals) or pathogen propagules values should be provided.\n\nSADIE quantifies spatial pattern by calculating the minimum total distance to regularity. That is, the distance that individuals must be moved from the starting point defined by the observed counts to the end point at which there is the same number of individuals in each sampling unit. Therefore, if the data are highly aggregated, the distance to regularity will be large, but if the data are close to regular to start with, the distance to regularity will be smaller.\n\nThe null hypothesis to test is that the observed pattern is random. SADIE calculates an index of aggregation (*Ia*). When this is equal to 1, the pattern is random. If this is greater than 1, the pattern is aggregated. Hypothesis testing is based on the randomization procedure. The null hypothesis of randomness, with an alternative hypothesis of aggregation.\n\nAn extension was made to quantify the contribution of each sampling unit count to the observed pattern. Regions with large counts are defined as patches and regions with small counts are defined as gaps. For each sampling unit, a clustering index is calculated and can be mapped.\n\nIn R, we can use the `sadie()` function of the *epiphy* package [@gigot2018]. The function computes the different indices and probabilities based on the distance to regularity for the observed spatial pattern and a specified number of random permutations of this pattern. To run the analysis, the dataframe should have only three columns: the first two must be the x and y coordinates and the third one the observations. Let's continue working with the simulated epidemic dataset named `epi2`. We can map the original data as follows:\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-mapgrouped_25254ed21697d95c5d2d6d6731cec7ff'}\n\n```{.r .cell-code}\nepi2 |>\n  ggplot(aes(x, y, label = n, fill = n)) +\n  geom_tile() +\n  geom_text(size = 5, color = \"white\") +\n  theme_void() +\n  coord_fixed() +\n  scale_fill_gradient(low = \"gray70\", high = \"darkred\")\n```\n\n::: {.cell-output-display}\n![Spatial map for the number of diseased plants per quadrat (n = 144) in simulated epidemic](spatial-tests_files/figure-pdf/fig-mapgrouped-1.pdf){#fig-mapgrouped fig-pos='H'}\n:::\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-61_d59236bb028e4bd9718bc4b4d6efb2bf'}\n\n```{.r .cell-code}\nlibrary(epiphy)\nsadie_epi2 <- sadie(epi2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nComputation of Perry's indices:\n```\n:::\n\n```{.r .cell-code}\nsadie_epi2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial Analysis by Distance IndicEs (sadie)\n\nCall:\nsadie.data.frame(data = epi2)\n\nIa: 2.4622 (Pa = < 2.22e-16)\n```\n:::\n:::\n\n\n\nThe simple output shows the *Ia* value and associated *P*-value. As suggested by the low value of the *P*-value, the pattern is highly aggregated. The `summary()` function provides a more complete information such as the overall inflow and outflow measures. A dataframe with the clustering index for each sampling unit is also provided using the `summary()` function.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-62_f674fe7f56c7c855c52d695d4f1acb16'}\n\n```{.r .cell-code}\nsummary(sadie_epi2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nsadie.data.frame(data = epi2)\n\nFirst 6 rows of clustering indices:\n  x y  i cost_flows      idx_P idx_LMX prob\n1 1 1  2 -11.382725 -7.2242617      NA   NA\n2 1 2  2  -9.461212 -6.2258877      NA   NA\n3 1 3  3  -7.299482 -5.3390880      NA   NA\n4 1 4 33   1.000000  0.8708407      NA   NA\n5 1 5  4  -5.830952 -3.6534511      NA   NA\n6 1 6  0  -5.301329 -2.9627172      NA   NA\n\nSummary indices:\n                      overall    inflow  outflow\nPerry's index        2.495346 -2.811023 2.393399\nLi-Madden-Xu's index       NA        NA       NA\n\nMain outputs:\nIa: 2.4622 (Pa = < 2.22e-16)\n\n'Total cost': 201.6062\nNumber of permutations: 100\n```\n:::\n:::\n\n\n\nThe `plot()` function allows to map the clustering indices and so to identify regions of patches (red, outflow) and gaps (blue, inflow).\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-sadie1_a6f3439e81321cc56291a24e1a54c339'}\n\n```{.r .cell-code}\nplot(sadie_epi2)\n```\n\n::: {.cell-output-display}\n![Map of the SADIE clustering indices where red identifiy patches (outflow) and blue identify gaps (inflow)](spatial-tests_files/figure-pdf/fig-sadie1-1.pdf){#fig-sadie1 fig-pos='H'}\n:::\n:::\n\n\n\nA isocline plot can be obtained by setting the `isocline` argument as `TRUE`.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-sadie2_032e4de4a2e90a8062e9b7f6bc7fc7db'}\n\n```{.r .cell-code}\nplot(sadie_epi2, isoclines = TRUE)\n```\n\n::: {.cell-output-display}\n![Map of the SADIE clustering indices](spatial-tests_files/figure-pdf/fig-sadie2-1.pdf){#fig-sadie2 fig-pos='H'}\n:::\n:::\n\n\n\n## Sparsely sampled data\n\nDifferent from intensively mapped data, sparsely sampled data do not contain information about the spatial location of the units, and so it is not taken into account in the analysis. The analysis of sparsely sampled data usually involves characterizing the extent of variability in the mean level of disease intensity per sampling unit [@chapter2017]. There are two types of approaches to analyse these data in the context of spatial patterns of plant disease epidemics: 1) testing the goodness of fit to statistical probability distributions and 2) calculating indices of aggregation. These will be discussed further separated depending on the nature of the data, whether count or incidence (proportion), for which specific distributions are assumed to describe the data.\n\n### Count data\n\n#### Fit to distributions\n\nTwo statistical distributions can be adopted as reference for the description of random or aggregated patterns of disease data in the form of counts of infection within sampling units. Take the count of lesions on a leaf, or the count of diseased plants on a quadrat, as an example. If the presence of a lesion/diseased plant does not increase or decrease the chance that other lesions/diseased plants will occur, the *Poisson* distribution describes the distribution of lesions on the leaf. Otherwise, the *negative binomial* provides a better description.\n\nLet's work with the previous simulation data of 144 quadrats with a variable count of diseased plants per quadrat (in a maximum of 100). Notice that we won't consider the location of each quadrat as in the previous analyses of intensively mapped data. We only need the vector with the number of infected units per sampling unit.\n\nThe *epiphy* package provides a function called `fit_two_distr()`, which allows fitting these two distribution for count data. In this case, either randomness assumption (Poisson distributions) or aggregation assumption (negative binomial) are made, and then, a goodness-of-fit comparison of both distributions is performed using a log-likelihood ratio test. The function requires a dataframe created using the `count()` function where the number of infection units is designated as `i`. It won't work with a single vector of numbers. We create the dataframe using:\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-65_56f4f56d9e8da150cb8d17e14f4683ec'}\n\n```{.r .cell-code}\ndata_count <- epi2 |> \n  mutate(i = n) |>  # create i vector\n  epiphy::count()   # create the map object of count class\n```\n:::\n\n\n\nWe can now run the function that will look fo the the vector `i`. The function returns a list of four components including the outputs of the fitting process for both distribution and the result of the log-likelihood ratio test, the `llr`.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-66_9da279f5ed42524f66a24569170d7759'}\n\n```{.r .cell-code}\nfit_data_count <- fit_two_distr(data_count)\nsummary(fit_data_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFitting of two distributions by maximum likelihood\nfor 'count' data.\nParameter estimates:\n\n(1) Poisson (random):\n       Estimate  Std.Err Z value    Pr(>z)    \nlambda 27.85417  0.43981  63.333 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(2) Negative binomial (aggregated):\n       Estimate    Std.Err Z value    Pr(>z)    \nk     0.6327452  0.0707846  8.9390 < 2.2e-16 ***\nmu   27.8541667  2.9510198  9.4388 < 2.2e-16 ***\nprob  0.0222118  0.0033463  6.6378 3.184e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-67_25255c08ee39e78a8afc409313f65fb9'}\n\n```{.r .cell-code}\nfit_data_count$llr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLikelihood ratio test\n\n               LogLik Df  Chisq Pr(>Chisq)    \nrandom :     -2654.71                         \naggregated :  -616.51  1 4076.4  < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\nThe very low value of the *P*-value of the LLR test suggest that the negative binomial provides a better fit to the data. The `plot()` function allows for visualizing the expected random and aggregated frequencies together with the observed frequencies. The number of breaks can be adjusted as indicated.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-freq_704b884d81a4c953812d83b417939dcb'}\n\n```{.r .cell-code}\nplot(fit_data_count, breaks = 5) \n```\n\n::: {.cell-output-display}\n![Frequencies of the observed and expected aggregated and random distributions](spatial-tests_files/figure-pdf/fig-freq-1.pdf){#fig-freq fig-pos='H'}\n:::\n:::\n\n\n\nSee below another way to plot by extracting the frequency data (and pivoting from wide to long format) from the generated list and using *ggplot*. Clearly, the negative binomial is a better description for the observed count data.\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/fig-freq1_9e618f2dcc9775420ae5bdd40d67ba2e'}\n\n```{.r .cell-code}\ndf <- fit_data_count$freq |>\n  pivot_longer(2:4, names_to = \"pattern\", values_to = \"value\")\n\ndf |>\n  ggplot(aes(category, value, fill = pattern)) +\n  geom_col(position = \"dodge\", width = 2) +\n  scale_fill_manual(values = c(\"gray70\", \"darkred\", \"steelblue\")) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![Frequencies of the observed and expected aggregated and random distributions](spatial-tests_files/figure-pdf/fig-freq1-1.pdf){#fig-freq1 fig-pos='H'}\n:::\n:::\n\n\n\n#### Aggregation indices\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-70_36785ac880951df5db46f8da2bee1bbe'}\n\n```{.r .cell-code}\nidx <- agg_index(data_count, method = \"fisher\")\nidx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFisher's index of dispersion:\n(Version for count data)\n34.25\n```\n:::\n\n```{.r .cell-code}\nchisq.test(idx)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tChi-squared test for (N - 1)*index following a chi-squared\n\tdistribution (df = N - 1)\n\ndata:  idx\nX-squared = 4897.2, df = 143, p-value < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\nz.test(idx)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tOne-sample z-test\n\ndata:  idx\nz = 82.085, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n:::\n\n```{.r .cell-code}\n# Lloyd index\n\nidx_lloyd <- agg_index(data_count, method = \"lloyd\")\nidx_lloyd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLloyd's index of patchiness:\n2.194\n```\n:::\n\n```{.r .cell-code}\nidx_mori <- agg_index(data_count, method = \"morisita\")\nidx_mori\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMorisita's coefficient of dispersion:\n(Version for count data)\n2.186\n```\n:::\n\n```{.r .cell-code}\n# Using the vegan package\nlibrary(vegan)\nz <- data_count$data$i\nmor <- dispindmorisita(z)\nmor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      imor     mclu      muni      imst pchisq\n1 2.185591 1.008728 0.9922162 0.5041152      0\n```\n:::\n:::\n\n\n\n#### Power law\n\nWhen we have a collection of count data sets at the sampling unit scale the Taylor's power law (TPL) can be used to assess the overall degree of heterogeneity.\n\n### Incidence data\n\n#### Fit to distributions\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-71_e6c99783a58c816fda9968fabf5a861a'}\n\n```{.r .cell-code}\ntas <-\n  read.csv(\n    \"https://www.apsnet.org/edcenter/disimpactmngmnt/topc/EcologyAndEpidemiologyInR/SpatialAnalysis/Documents/tasmania_test_1.txt\",\n    sep = \"\"\n  )\nhead(tas,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   quad group_size count\n1     1          6     4\n2     2          6     6\n3     3          6     6\n4     4          6     6\n5     5          6     6\n6     6          6     6\n7     7          6     6\n8     8          6     6\n9     9          6     4\n10   10          6     6\n```\n:::\n\n```{.r .cell-code}\n# Create incidence object for epiphy\ndat_tas <- tas |>\n  mutate(n = group_size, i = count) |>\n  epiphy::incidence()\n\n## Fit to two distributions\nfit_tas <- fit_two_distr(dat_tas)\nsummary(fit_tas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFitting of two distributions by maximum likelihood\nfor 'incidence' data.\nParameter estimates:\n\n(1) Binomial (random):\n     Estimate Std.Err Z value    Pr(>z)    \nprob  0.90860 0.01494  60.819 < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(2) Beta-binomial (aggregated):\n      Estimate  Std.Err Z value    Pr(>z)    \nalpha 1.923479 0.869621  2.2119  0.026976 *  \nbeta  0.181337 0.075641  2.3973  0.016514 *  \nprob  0.913847 0.023139 39.4943 < 2.2e-16 ***\nrho   0.322080 0.096414  3.3406  0.000836 ***\ntheta 0.475101 0.209789  2.2647  0.023534 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n```{.r .cell-code}\nfit_tas$llr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLikelihood ratio test\n\n              LogLik Df  Chisq Pr(>Chisq)    \nrandom :     -75.061                         \naggregated : -57.430  1 35.263   2.88e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n```{.r .cell-code}\nplot(fit_tas)\n```\n\n::: {.cell-output-display}\n![](spatial-tests_files/figure-pdf/unnamed-chunk-71-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n#### Aggregation indices\n\nglm model\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-72_7b471292e76a6b397e1d3df6691216e2'}\n\n```{.r .cell-code}\nbinom.tas = glm(cbind(count, group_size - count) ~ 1,\n                family = binomial,\n                data = tas)\nsummary(binom.tas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = cbind(count, group_size - count) ~ 1, family = binomial, \n    data = tas)\n\nDeviance Residuals: \n   Min      1Q  Median      3Q     Max  \n-3.447   1.073   1.073   1.073   1.073  \n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)   2.2967     0.1799   12.77   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 117.76  on 61  degrees of freedom\nResidual deviance: 117.76  on 61  degrees of freedom\nAIC: 152.12\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n\n```{.r .cell-code}\nlibrary(performance)\ncheck_overdispersion(binom.tas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Overdispersion test\n\n       dispersion ratio =   2.348\n  Pearson's Chi-Squared = 143.206\n                p-value = < 0.001\n```\n:::\n:::\n\n\n\nepiphy(c-alpha test)\n\n\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-73_133a3b545ffe2999d08264db39802ea5'}\n\n```{.r .cell-code}\nlibrary(epiphy)\ntas2 <- tas |>\n  mutate(i = count,\n         n = group_size) |>  # create i vector\n  epiphy::incidence()\n\nt <- agg_index(tas2, flavor = \"incidence\")\nt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFisher's index of dispersion:\n(Version for incidence data)\n2.348\n```\n:::\n:::\n\n::: {.cell hash='spatial-tests_cache/pdf/unnamed-chunk-74_5608ca3e00e4dec0d692fa926ee3f709'}\n\n```{.r .cell-code}\ncalpha.test(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tC(alpha) test\n\ndata:  t\nz = 7.9886, p-value = 1.365e-15\n```\n:::\n:::\n\n\n\n#### Binary power law\n\nWhen we have a collection of incidence data sets at the sampling unit scale the binary form of the power law can be used to assess the overall degree of heterogeneity. This spatial analysis method describes the relationship between the observed variance of diseased individuals within a data set and the corresponding variance under the assumption that the data have a random distribution distribution (i.e., Binomial for proportion data).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"version\",\"src\",\"meta\",\"script\",\"stylesheet\",\"head\",\"attachment\",\"package\",\"all_files\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"html_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"htmlwidgets\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"1.6.2\"]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"file\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"www\"]}]},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"htmlwidgets.js\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"htmlwidgets\"]},{\"type\":\"logical\",\"attributes\":{},\"value\":[true]}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"version\",\"src\",\"meta\",\"script\",\"stylesheet\",\"head\",\"attachment\",\"package\",\"all_files\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"html_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"datatables-css\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"0.0.0\"]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"file\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"htmlwidgets/css\"]}]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"datatables-crosstalk.css\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"DT\"]},{\"type\":\"logical\",\"attributes\":{},\"value\":[true]}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"version\",\"src\",\"meta\",\"script\",\"stylesheet\",\"head\",\"attachment\",\"package\",\"all_files\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"html_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"datatables-binding\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"0.27\"]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"file\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"htmlwidgets\"]}]},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"datatables.js\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"DT\"]},{\"type\":\"logical\",\"attributes\":{},\"value\":[false]}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"version\",\"src\",\"meta\",\"script\",\"stylesheet\",\"head\",\"attachment\",\"package\",\"all_files\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"html_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"jquery\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"3.6.0\"]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"file\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"lib/3.6.0\"]}]},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"jquery-3.6.0.min.js\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"jquerylib\"]},{\"type\":\"logical\",\"attributes\":{},\"value\":[true]}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"version\",\"src\",\"meta\",\"script\",\"stylesheet\",\"head\",\"attachment\",\"package\",\"all_files\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"html_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"dt-core\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"1.12.1\"]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"file\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"/Users/emerson/Library/R/x86_64/4.1/library/DT/htmlwidgets/lib/datatables\"]}]},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"js/jquery.dataTables.min.js\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"css/jquery.dataTables.min.css\",\"css/jquery.dataTables.extra.css\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"logical\",\"attributes\":{},\"value\":[false]}]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"name\",\"version\",\"src\",\"meta\",\"script\",\"stylesheet\",\"head\",\"attachment\",\"package\",\"all_files\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"html_dependency\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"crosstalk\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"1.2.0\"]},{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"file\"]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"www\"]}]},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"js/crosstalk.min.js\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"css/crosstalk.min.css\"]},{\"type\":\"NULL\"},{\"type\":\"NULL\"},{\"type\":\"character\",\"attributes\":{},\"value\":[\"crosstalk\"]},{\"type\":\"logical\",\"attributes\":{},\"value\":[true]}]}]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}