{
  "hash": "6f3ce39641c3340ff68fc6d9790e3c9d",
  "result": {
    "markdown": "---\ntitle: \"Model fitting\"\n---\n\n\nIn model fitting for temporal analysis, the objective is to determine which previously-reviewed epidemiological (population dynamics) models best fit the data from actual epidemics. Doing so allows us to obtain two key parameters: the initial inoculum and the apparent infection rate.\n\nThere are essentially two methods for achieving this: linear regression and non-linear regression modeling. We'll begin with linear regression, which is computationally simpler. I'll illustrate the procedure using both built-in R functions and custom functions from the epifitter package [@alves2021a]. Epifitter offers a set of user-friendly functions that can fit and rank the best models for a given epidemic.\n\nTo exemplify, we'll continue examining a previously shown curve that represents the incidence of the tobacco etch virus, a disease affecting peppers, over time. This dataset is featured in Chapter 3 of the book, \"Study of Plant Disease Epidemics\" [@chapter2017b]. While the book presents SAS code for certain analyses, we offer an alternative code that accomplishes similar analyses, even if it doesn't replicate the book's results exactly.\n\n## Linear regression: single epidemics\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-1_13cd7abfc6e42250066a89d6f66bd4cd'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ntheme_set(theme_gray(base_size = 16))\ndpc <- \n  tribble(\n   ~t,  ~y, \n   0,  0.1, \n   7,  1, \n  14,  9, \n  21,  25, \n  28,  80, \n  35, 98, \n  42, 99, \n  49, 99.9\n  )\n```\n:::\n\n::: {.cell hash='temporal-fitting_cache/html/fig-dpc1_38e8332b55f0d083db651a73a38f8f4e'}\n\n```{.r .cell-code}\ndpc |> \n  ggplot(aes(t, y))+\n  geom_point(size =3)+\n  geom_line()+\n  labs(x = \"Time\", y = \"Disease intensity (%)\")\n```\n\n::: {.cell-output-display}\n![Disease progress curves for one tobacco etch epidemics in pepper. Reproduced from @chapter2017b page 94](temporal-fitting_files/figure-html/fig-dpc1-1.png){#fig-dpc1 width=672}\n:::\n:::\n\n\nTo start, we'll need to transform the disease intensity (in proportion scale) data according to each of the models we aim to fit. In this instance, we'll look at the four models discussed in the previous chapter: exponential, monomolecular, logistic, and Gompertz. We can use the `mutate()` function of *dplyr* package. The transformed y will be referred to as y* (or y2 in the code) followed by the letter E, M, L or G, for each model (exponential, monomolecular, etc) respectively.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-3_2c20b6d708e98669b2cc56bc0d8ea8ba'}\n\n```{.r .cell-code}\ndpc1 <- dpc |> \n  mutate(y = y/100) |> # transform to proportion\n  mutate(exponential = log(y),\n         monomolecular = log(1 / (1 - y)),\n         logistic = log(y / (1 - y)),\n         gompertz = -log(-log(y)))\nknitr::kable(round(dpc1, 4)) \n```\n\n::: {.cell-output-display}\n|  t|     y| exponential| monomolecular| logistic| gompertz|\n|--:|-----:|-----------:|-------------:|--------:|--------:|\n|  0| 0.001|     -6.9078|        0.0010|  -6.9068|  -1.9326|\n|  7| 0.010|     -4.6052|        0.0101|  -4.5951|  -1.5272|\n| 14| 0.090|     -2.4079|        0.0943|  -2.3136|  -0.8788|\n| 21| 0.250|     -1.3863|        0.2877|  -1.0986|  -0.3266|\n| 28| 0.800|     -0.2231|        1.6094|   1.3863|   1.4999|\n| 35| 0.980|     -0.0202|        3.9120|   3.8918|   3.9019|\n| 42| 0.990|     -0.0101|        4.6052|   4.5951|   4.6001|\n| 49| 0.999|     -0.0010|        6.9078|   6.9068|   6.9073|\n:::\n:::\n\n\nNow we can plot the curves using the transformed values regressed against time. The curve that appears most linear, closely coinciding with the regression fit line, is a strong candidate for the best-fitting model. To accomplish this, we'll first reshape the dataframe into long format, and then generate plots for each of the four models.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-models_583d7ff2423101781c31bc2c91495584'}\n\n```{.r .cell-code}\ndpc2 <- dpc1 |> \n  pivot_longer(3:6, names_to = \"model\", values_to = \"y2\") \n\n\ndpc2 |> \n  ggplot(aes(t, y2))+\n  geom_point()+\n  geom_smooth(method = \"lm\", color = \"black\", se = F)+\n  facet_wrap(~ model)+\n  labs(x = \"Time\", y = \"Transformed value (y*)\",\n       color = \"Model\")+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Curves of the transformed data for each epidemiological against time. The goal is to check which of the models provides the best fit based on the straight line](temporal-fitting_files/figure-html/fig-models-1.png){#fig-models width=672}\n:::\n:::\n\n\nFor this particular curve, it's readily apparent that the logistic model offers the best fit to the data, as evidenced by the data points being closely aligned with the regression line, compared to the other models. However, to make a more nuanced decision between the logistic and Gompertz models---which are both typically used for sigmoid curves---we can rely on additional statistical measures.\n\nSpecifically, we can fit a regression model for each and examine key metrics such as the R-squared value and the residual standard error. To further validate the model's accuracy, we can use Lin's Concordance Correlation Coefficient to assess how closely the model's predictions match the actual (transformed) data points.\n\nFor this exercise, let's focus on the logistic and Gompertz models. We'll start by fitting the logistic model and then move on to analyzing the summary of the regression model.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-5_8daba3f29a92feb6304375186a3d7626'}\n\n```{.r .cell-code}\nlogistic <- dpc2 |> \n  filter(model == \"logistic\")\n\nm_logistic <- lm(y2 ~ t, data = logistic)\n\n\n# R-squared\nsummary(m_logistic)$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9923659\n```\n:::\n\n```{.r .cell-code}\n# RSE \nsummary(m_logistic)$sigma\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.4523616\n```\n:::\n\n```{.r .cell-code}\n# calculate the Lin's CCC\nlibrary(epiR)\nccc_logistic <- epi.ccc(logistic$y2, predict(m_logistic))\nccc_logistic$rho.c[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        est\n1 0.9961683\n```\n:::\n:::\n\n\nWe repeat the procedure for the Gompertz model.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-6_74e08c3234df1584a249299e01d6c26d'}\n\n```{.r .cell-code}\ngompertz <- dpc2 |> \n  filter(model == \"gompertz\")\n\nm_gompertz <- lm(y2 ~ t, data = gompertz)\n\n# R-squared\nsummary(m_gompertz)$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9431066\n```\n:::\n\n```{.r .cell-code}\n# RSE \nsummary(m_gompertz)$sigma\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8407922\n```\n:::\n\n```{.r .cell-code}\n# calculate the Lin's CCC\nlibrary(epiR)\nccc_gompertz <- epi.ccc(gompertz$y2, predict(m_gompertz))\nccc_gompertz$rho.c[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        est\n1 0.9707204\n```\n:::\n:::\n\n\nNext, let's extract the two parameters of interest from each fitted model and incorporate them into the integral form of the respective models. To do this, we'll need to back-transform the intercept, which represents the initial inoculum. This can be accomplished using specific equations, which we'll outline next.\n\n| Model         | Transformation   | Back-transformation |\n|---------------|------------------|-------------------|\n| Exponential   | log(y)           | exp(y*E)            |\n| Monomolecular | log(1 / (1 - y)) | 1 - exp(-y*M)       |\n| Logistic      | log(y / (1 - y)) | 1 / (1 + exp(-y*L)) |\n| Gompertz      | -log(-log(y))    | exp(-exp(-y*G))     |\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-7_ca3935107c3b25db932a10da5ca0333f'}\n\n```{.r .cell-code}\nrL <- m_logistic$coefficients[2]\nrL\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        t \n0.2784814 \n```\n:::\n\n```{.r .cell-code}\ny02 <- m_logistic$coefficients[1]\ny0L = 1 / (1 + exp(-y02))\ny0L\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept) \n0.001372758 \n```\n:::\n\n```{.r .cell-code}\nrG <-m_gompertz$coefficients[2]\nrG\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        t \n0.1848378 \n```\n:::\n\n```{.r .cell-code}\ny03 <- m_gompertz$coefficients[1]\ny0G <- exp(-exp(-y03))\ny0G\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n (Intercept) \n1.968829e-09 \n```\n:::\n:::\n\n\nNow the plot:\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-logistic-gompertz_c4fad9c21e7d0feb0954506984701bd8'}\n\n```{.r .cell-code}\nlogistic |>\n  ggplot(aes(t, y)) +\n  geom_point(size = 2)+\n  stat_function(\n    linetype = 2,\n    fun = function(t) 1 / (1 + ((1 - y0L) / y0L) * exp(-rL * t)))+\nstat_function(\n    linetype = 1,\n    fun = function(t) exp(log(y0G) * exp(-rG * t))\n  )+\n  labs(x = \"Time\", y = \"Disease intensity\")\n```\n\n::: {.cell-output-display}\n![Disease progress curve and the fit of the logistic (dashed line) and the Gompertz (solid line) based on parameters estimated using linear regression](temporal-fitting_files/figure-html/fig-logistic-gompertz-1.png){#fig-logistic-gompertz width=672}\n:::\n:::\n\n\nIn this case, it's clear that the logistic model (the solid line above) emerges as the best fit based on our statistical evaluation. The approach for model selection outlined here is straightforward and manageable when dealing with a single epidemic and comparing only two models. However, real-world scenarios often require analyzing multiple curves and fitting various models to each, making manual comparison impractical for selecting a single best-fitting model. To streamline this task, it's advisable to automate the process using custom functions designed to simplify the coding work involved.\n\nThat's where the epifitter package comes into play! This package offers a range of custom functions designed to automate the model fitting and selection process, making it much more efficient to analyze multiple curves across different epidemics. By using epifitter, one can expedite the statistical evaluation needed to identify the best-fitting models.\n\n## Non linear regression\n\nAlternatively, one can fit a nonlinear model to the data for each combination of curve and model using the nlsLM function in R of the *minpack.lm* package. \n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-9_e3ec8160d3d5822a5cee66d433adcaa9'}\n\n```{.r .cell-code}\nlibrary(minpack.lm)\nfit_logistic <- nlsLM(y/100 ~ 1 / (1+(1/y0-1)*exp(-r*t)), \n           start = list(y0 = 0.01, r = 0.3), \n           data = dpc)\n\nsummary(fit_logistic)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFormula: y/100 ~ 1/(1 + (1/y0 - 1) * exp(-r * t))\n\nParameters:\n    Estimate Std. Error t value Pr(>|t|)    \ny0 0.0003435  0.0002065   1.663    0.147    \nr  0.3321352  0.0249015  13.338  1.1e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.02463 on 6 degrees of freedom\n\nNumber of iterations to convergence: 15 \nAchieved convergence tolerance: 1.49e-08\n```\n:::\n\n```{.r .cell-code}\nfit_gompertz <- nlsLM(y/100 ~ exp(log(y0/1)*exp(-r*t)), \n                    start = list(y0 = 0.01, r = 0.1), \n                    data = dpc)\nsummary(fit_gompertz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFormula: y/100 ~ exp(log(y0/1) * exp(-r * t))\n\nParameters:\n    Estimate Std. Error t value Pr(>|t|)   \ny0 2.038e-15  4.950e-14   0.041  0.96850   \nr  1.643e-01  3.033e-02   5.416  0.00164 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.06691 on 6 degrees of freedom\n\nNumber of iterations till stop: 50 \nAchieved convergence tolerance: 1.49e-08\nReason stopped: Number of iterations has reached `maxiter' == 50.\n```\n:::\n:::\n\n\nWe can see that the model coefficients are not the same as those estimated using linear regression. Among other reasons, `nls()` often uses iterative techniques to estimate parameters, such as the Levenberg-Marquardt algorithm, which may provide different estimates than algebraic methods used in linear regression. While both methods aim to fit a model to data, they do so in ways that have distinct assumptions, strengths, and weaknesses, and this can result in different estimated parameters. \n\nBoth approaches—nonlinear least squares and linear regression on transformed data—have their own merits and limitations. The choice between the two often depends on various factors like the nature of the data, the underlying assumptions, and the specific requirements of the analysis. For an epidemiologist, the choice might come down to preference, familiarity with the techniques, or specific aims of the analysis. \n\nIn summary, both methods are valid tools in the toolkit of an epidemiologist or any researcher working on curve fitting and model selection. Understanding the nuances of each can help in making an informed choice tailored to the needs of a particular study.\n\n\n## epifitter - multiple epidemics\n\nWe will now examine three disease progress curves (DPCs) representing the incidence of the tobacco etch virus, a disease affecting peppers. Incidence evaluations were conducted at 7-day intervals up to 49 days. The relevant data can be found in Chapter 4, page 93, of the book \"Study of Plant Disease Epidemics\" [@chapter2017b]. To get started, let's input the data manually and create a data frame. The first column will represent the assessment time, while the remaining columns will correspond to the treatments, referred to as 'groups' in the book, ranging from 1 to 3.\n\n## Entering data\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-10_464138929d1c226ca9e3512bced34660'}\n\n```{.r .cell-code}\nlibrary(tidyverse) # essential packages \ntheme_set(theme_bw(base_size = 16)) # set global theme\n```\n:::\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-11_8ccd74aa8a1ee0037e2f1d776f7b6c45'}\n\n```{.r .cell-code}\npepper <- \n  tribble(\n   ~t,  ~`1`,  ~`2`,  ~`3`,\n   0,  0.08, 0.001, 0.001,\n   7,  0.13,  0.01, 0.001,\n  14,  0.78,  0.09,  0.01,\n  21,  0.92,  0.25,  0.05,\n  28,  0.99,   0.8,  0.18,\n  35, 0.995,  0.98,  0.34,\n  42, 0.999,  0.99,  0.48,\n  49, 0.999, 0.999,  0.74\n  ) \n```\n:::\n\n\n## Visualize the DPCs\n\nBefore proceeding with model selection and fitting, let's visualize the three epidemics. The code below reproduces quite exactly the top plot of Fig. 4.15 (@chapter2017b page 94). The appraisal of the curves might give us a hint on which models are the best candidates.\n\nBecause the data was entered in the wide format (each DPC is in a different column) we need to reshape it to the long format. The `pivot_longer()` function will do the job of reshaping from wide to long format so we can finally use the `ggplot()` function to produce the plot.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-dpcs_346553f3e56a3f29d7beebebf3258852'}\n\n```{.r .cell-code}\npepper |> \n  pivot_longer(2:4, names_to =\"treat\", values_to = \"inc\") |> \n  ggplot (aes(t, inc, \n              linetype = treat, \n              shape = treat, \n              group = treat))+\n  scale_color_grey()+\n  theme_grey()+\n  geom_line(linewidth = 1)+\n  geom_point(size =3, shape = 16)+\n  annotate(geom = \"text\", x = 15, y = 0.84, label = \"1\")+\n  annotate(geom = \"text\", x = 23, y = 0.6, label = \"2\")+\n  annotate(geom = \"text\", x = 32, y = 0.33, label = \"3\")+\n  labs(y = \"Disease incidence (y)\",\n       x = \"Time (days)\")+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Disease progress curves for three tobacco etch epidemics in pepper. Reproduced from @chapter2017b page 94](temporal-fitting_files/figure-html/fig-dpcs-1.png){#fig-dpcs width=672}\n:::\n:::\n\n\nMost of the three curves show a sigmoid shape with the exception of group 3 that resembles an exponential growth, not reaching the maximum value, and thus suggesting an incomplete epidemic. We can easily eliminate the monomolecular and exponential models and decide on the other two non-flexible models: logistic or Gompertz. To do that, let's proceed to model fitting and evaluate the statistics for supporting a final decision. There are two modeling approaches for model fitting in epifitter: the **linear** or **nonlinear** parameter-estimation methods.\n\n### epifitter: linear regression\n\nAmong the several options offered by *epifitter* we start with the simplest one, which is to fit a model to a single epidemics using the linear regression approach. For such, the `fit_lin()` requires two arguments: time (`time`) and disease intensity (`y`) each one as a vector stored or not in a dataframe.\n\nSince we have three epidemics, `fit_lin()` will be use three times. The function produces a list object with six elements. Let's first look at the `Stats` dataframe of each of the three lists named `epi1` to `epi3`.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-13_72873cc10da24e3a0572d3aea03aea70'}\n\n```{.r .cell-code}\nlibrary(epifitter)\nepi1 <- fit_lin(time = pepper$t,  \n                y = pepper$`1` )\nknitr::kable(epi1$Stats)\n```\n\n::: {.cell-output-display}\n|              |    CCC| r_squared|    RSE|\n|:-------------|------:|---------:|------:|\n|Gompertz      | 0.9848|    0.9700| 0.5911|\n|Monomolecular | 0.9838|    0.9681| 0.5432|\n|Logistic      | 0.9782|    0.9572| 0.8236|\n|Exponential   | 0.7839|    0.6447| 0.6705|\n:::\n:::\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-14_1db8870b363f1e989bea642898c3e8d3'}\n\n```{.r .cell-code}\nepi2 <- fit_lin(time = pepper$t,  \n  y = pepper$`2` )\nknitr::kable(epi2$Stats)\n```\n\n::: {.cell-output-display}\n|              |    CCC| r_squared|    RSE|\n|:-------------|------:|---------:|------:|\n|Logistic      | 0.9962|    0.9924| 0.4524|\n|Gompertz      | 0.9707|    0.9431| 0.8408|\n|Monomolecular | 0.9248|    0.8601| 1.0684|\n|Exponential   | 0.8971|    0.8134| 1.2016|\n:::\n:::\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-15_85f204f474e7434d3ef773f312c8a27d'}\n\n```{.r .cell-code}\nepi3 <- fit_lin(time = pepper$t,  \n  y = pepper$`3` )\nknitr::kable(epi3$Stats)\n```\n\n::: {.cell-output-display}\n|              |    CCC| r_squared|    RSE|\n|:-------------|------:|---------:|------:|\n|Logistic      | 0.9829|    0.9665| 0.6045|\n|Gompertz      | 0.9825|    0.9656| 0.2263|\n|Exponential   | 0.9636|    0.9297| 0.7706|\n|Monomolecular | 0.8592|    0.7531| 0.2534|\n:::\n:::\n\n\nThe statistics of the model fit confirms our initial guess that the predictions by the logistic or the Gompertz are closer to the observations than predictions by the other models. There is a slight difference between them based on these statistics. However, to pick one of the models, it is important to inspect the curves with the observed and predicted values to check which model is best for all curves. For such, we can use the `plot_fit()` function from *epifitter* to explore visually the fit of the four models to each curve.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-16_9ea52639e41249e032e4df32fa0de2a1'}\n\n```{.r .cell-code}\nplot_fit(epi1)+\n  ylim(0,1)+\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](temporal-fitting_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(epi1$stats_all)\n```\n\n::: {.cell-output-display}\n| best_model|model         |         r|      r_se|  r_ci_lwr|  r_ci_upr|         v0|     v0_se| r_squared|       RSE|       CCC|         y0|  y0_ci_lwr| y0_ci_upr|\n|----------:|:-------------|---------:|---------:|---------:|---------:|----------:|---------:|---------:|---------:|---------:|----------:|----------:|---------:|\n|          1|Gompertz      | 0.1815713| 0.0130299| 0.1496882| 0.2134544| -1.2050364| 0.3815570| 0.9700273| 0.5911056| 0.9847857|  0.0355477|  0.0002059| 0.2693349|\n|          2|Monomolecular | 0.1616413| 0.0119739| 0.1323423| 0.1909404| -0.4625249| 0.3506326| 0.9681251| 0.5431977| 0.9838044| -0.5880787| -2.7452636| 0.3266178|\n|          3|Logistic      | 0.2104047| 0.0181544| 0.1659824| 0.2548270| -2.2715851| 0.5316185| 0.9572410| 0.8235798| 0.9781534|  0.0935038|  0.0273207| 0.2747287|\n|          4|Exponential   | 0.0487634| 0.0147802| 0.0125974| 0.0849293| -1.8090602| 0.4328113| 0.6446531| 0.6705085| 0.7839381|  0.1638080|  0.0568061| 0.4723623|\n:::\n\n```{.r .cell-code}\nplot_fit(epi2)+\n  ylim(0,1)+\n  scale_color_grey()+\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](temporal-fitting_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(epi2$stats_all)\n```\n\n::: {.cell-output-display}\n| best_model|model         |         r|      r_se|  r_ci_lwr|  r_ci_upr|        v0|     v0_se| r_squared|       RSE|       CCC|         y0|   y0_ci_lwr| y0_ci_upr|\n|----------:|:-------------|---------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|----------:|-----------:|---------:|\n|          1|Logistic      | 0.2784814| 0.0099716| 0.2540818| 0.3028809| -6.589560| 0.2919981| 0.9923659| 0.4523616| 0.9961683|  0.0013728|   0.0006724| 0.0028007|\n|          2|Gompertz      | 0.1848378| 0.0185339| 0.1394871| 0.2301886| -2.998021| 0.5427290| 0.9431066| 0.8407922| 0.9707204|  0.0000000|   0.0000000| 0.0049309|\n|          3|Monomolecular | 0.1430234| 0.0235503| 0.0853979| 0.2006489| -1.325645| 0.6896255| 0.8600832| 1.0683633| 0.9247793| -2.7646136| -19.3503499| 0.3035837|\n|          4|Exponential   | 0.1354579| 0.0264869| 0.0706469| 0.2002689| -5.263915| 0.7756171| 0.8134015| 1.2015809| 0.8971003|  0.0051750|   0.0007757| 0.0345258|\n:::\n\n```{.r .cell-code}\nplot_fit(epi3)+\n  ylim(0,1)+\n  scale_color_grey()+\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](temporal-fitting_files/figure-html/unnamed-chunk-16-3.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(epi3$stats_all)\n```\n\n::: {.cell-output-display}\n| best_model|model         |         r|      r_se|  r_ci_lwr|  r_ci_upr|         v0|     v0_se| r_squared|       RSE|       CCC|         y0|  y0_ci_lwr| y0_ci_upr|\n|----------:|:-------------|---------:|---------:|---------:|---------:|----------:|---------:|---------:|---------:|---------:|----------:|----------:|---------:|\n|          1|Logistic      | 0.1752146| 0.0133257| 0.1426077| 0.2078215| -7.1136060| 0.3902187| 0.9664590| 0.6045243| 0.9829434|  0.0008133|  0.0003132| 0.0021104|\n|          2|Gompertz      | 0.0647145| 0.0049874| 0.0525107| 0.0769182| -2.2849079| 0.1460470| 0.9655894| 0.2262550| 0.9824935|  0.0000541|  0.0000008| 0.0010358|\n|          3|Exponential   | 0.1513189| 0.0169860| 0.1097556| 0.1928822| -6.8629493| 0.4974031| 0.9297097| 0.7705736| 0.9635747|  0.0010458|  0.0003097| 0.0035322|\n|          4|Monomolecular | 0.0238957| 0.0055853| 0.0102291| 0.0375624| -0.2506567| 0.1635537| 0.7531307| 0.2533763| 0.8591837| -0.2848689| -0.9171854| 0.1389001|\n:::\n:::\n\n\n### epifitter: non linear regression\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-17_790ff2824b52a0a2ac686ae3753b9d0e'}\n\n```{.r .cell-code}\nepi11 <- fit_nlin(time = pepper$t,  \n                y = pepper$`1` )\nknitr::kable(epi11$Stats)\n```\n\n::: {.cell-output-display}\n|              |    CCC| r_squared|    RSE|\n|:-------------|------:|---------:|------:|\n|Gompertz      | 0.9963|    0.9956| 0.0381|\n|Logistic      | 0.9958|    0.9939| 0.0403|\n|Monomolecular | 0.9337|    0.8883| 0.1478|\n|Exponential   | 0.7161|    0.5903| 0.2770|\n:::\n\n```{.r .cell-code}\nepi22 <- fit_nlin(time = pepper$t,  \n                y = pepper$`2` )\nknitr::kable(epi22$Stats)\n```\n\n::: {.cell-output-display}\n|              |    CCC| r_squared|    RSE|\n|:-------------|------:|---------:|------:|\n|Logistic      | 0.9988|    0.9981| 0.0246|\n|Gompertz      | 0.9904|    0.9857| 0.0683|\n|Monomolecular | 0.8697|    0.8020| 0.2329|\n|Exponential   | 0.8587|    0.7862| 0.2413|\n:::\n\n```{.r .cell-code}\nepi33 <- fit_nlin(time = pepper$t,  \n                y = pepper$`3` )\nknitr::kable(epi33$Stats)\n```\n\n::: {.cell-output-display}\n|              |    CCC| r_squared|    RSE|\n|:-------------|------:|---------:|------:|\n|Logistic      | 0.9957|    0.9922| 0.0270|\n|Gompertz      | 0.9946|    0.9894| 0.0306|\n|Exponential   | 0.9880|    0.9813| 0.0445|\n|Monomolecular | 0.8607|    0.7699| 0.1426|\n:::\n:::\n\n\nAnd now we can produce the plot of the fitted curves together with the original incidence dat. The `stats_all` dataframe shows everything we need regarding the statistics and the values of the parameteres.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-18_d9fcc4dc6975a99ea220f9aa2df53df1'}\n\n```{.r .cell-code}\nplot_fit(epi11)+\n  scale_color_grey()+\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](temporal-fitting_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(epi11$stats_all)\n```\n\n::: {.cell-output-display}\n|model         |         y0|     y0_se|         r|      r_se| df|       CCC| r_squared|       RSE|  y0_ci_lwr| y0_ci_upr|   r_ci_lwr|  r_ci_upr| best_model|\n|:-------------|----------:|---------:|---------:|---------:|--:|---------:|---------:|---------:|----------:|---------:|----------:|---------:|----------:|\n|Gompertz      |  0.0000004| 0.0000017| 0.2865029| 0.0313159|  6| 0.9962708| 0.9956357| 0.0380871| -0.0000039| 0.0000046|  0.2098756| 0.3631302|          1|\n|Logistic      |  0.0092495| 0.0060330| 0.4181351| 0.0539931|  6| 0.9957910| 0.9938810| 0.0403179| -0.0055126| 0.0240117|  0.2860188| 0.5502513|          2|\n|Monomolecular | -0.0264718| 0.1405690| 0.0836206| 0.0212473|  6| 0.9337210| 0.8883222| 0.1477596| -0.3704319| 0.3174883|  0.0316303| 0.1356109|          3|\n|Exponential   |  0.4159606| 0.1376766| 0.0215063| 0.0088658|  6| 0.7160769| 0.5903409| 0.2770420|  0.0790782| 0.7528430| -0.0001874| 0.0432000|          4|\n:::\n\n```{.r .cell-code}\nplot_fit(epi22)+\n  scale_color_grey()+\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](temporal-fitting_files/figure-html/unnamed-chunk-18-2.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(epi22$stats_all)\n```\n\n::: {.cell-output-display}\n|model         |         y0|     y0_se|         r|      r_se| df|       CCC| r_squared|       RSE|  y0_ci_lwr| y0_ci_upr|  r_ci_lwr|  r_ci_upr| best_model|\n|:-------------|----------:|---------:|---------:|---------:|--:|---------:|---------:|---------:|----------:|---------:|---------:|---------:|----------:|\n|Logistic      |  0.0003435| 0.0002065| 0.3321341| 0.0249014|  6| 0.9988253| 0.9980693| 0.0246349| -0.0001618| 0.0008488| 0.2712025| 0.3930657|          1|\n|Gompertz      |  0.0000000| 0.0000000| 0.1618741| 0.0301525|  6| 0.9904450| 0.9856896| 0.0682506|  0.0000000| 0.0000000| 0.0880936| 0.2356545|          2|\n|Monomolecular | -0.1971531| 0.2005248| 0.0442060| 0.0131684|  6| 0.8696734| 0.8020353| 0.2328814| -0.6878195| 0.2935134| 0.0119840| 0.0764280|          3|\n|Exponential   |  0.1612234| 0.0848398| 0.0410936| 0.0125521|  6| 0.8587176| 0.7862042| 0.2412526| -0.0463722| 0.3688189| 0.0103797| 0.0718076|          4|\n:::\n\n```{.r .cell-code}\nplot_fit(epi33)+\n  scale_color_grey()+\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](temporal-fitting_files/figure-html/unnamed-chunk-18-3.png){width=672}\n:::\n\n```{.r .cell-code}\nknitr::kable(epi33$stats_all)\n```\n\n::: {.cell-output-display}\n|model         |         y0|     y0_se|         r|      r_se| df|       CCC| r_squared|       RSE|  y0_ci_lwr| y0_ci_upr|  r_ci_lwr|  r_ci_upr| best_model|\n|:-------------|----------:|---------:|---------:|---------:|--:|---------:|---------:|---------:|----------:|---------:|---------:|---------:|----------:|\n|Logistic      |  0.0056634| 0.0019662| 0.1249931| 0.0086711|  6| 0.9957129| 0.9922359| 0.0270311|  0.0008522| 0.0104746| 0.1037758| 0.1462105|          1|\n|Gompertz      |  0.0000002| 0.0000008| 0.0759837| 0.0061025|  6| 0.9945740| 0.9894187| 0.0305883| -0.0000017| 0.0000022| 0.0610515| 0.0909159|          2|\n|Exponential   |  0.0225267| 0.0072184| 0.0718824| 0.0070479|  6| 0.9880169| 0.9812854| 0.0445057|  0.0048638| 0.0401896| 0.0546367| 0.0891281|          3|\n|Monomolecular | -0.1371485| 0.1060292| 0.0169603| 0.0042530|  6| 0.8606954| 0.7698769| 0.1426044| -0.3965926| 0.1222956| 0.0065536| 0.0273669|          4|\n:::\n:::\n\n\nFor multiple epidemics, we can use another handy function that allows us to simultaneously fit the models to multiple DPC data. Different from `fit_lin()`, `fit_multi()` requires the data to be structured in the long format where there is a column specifying each of the epidemics.\n\nLet's then create a new data set called `pepper2` using the data transposing functions of the *tidyr* package.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-19_8e922de1414f8710461be14f79c25834'}\n\n```{.r .cell-code}\npepper2 <- pepper |> \n  pivot_longer(2:4, names_to =\"treat\", values_to = \"inc\")\n```\n:::\n\n\nNow we fit the models to all DPCs. Note that the name of the variable indicating the DPC code needs to be informed in `strata_cols` argument. To use the nonlinear regression approach we set `nlin` argument to `TRUE`.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-20_26f869b904d882f7d4e2f45fafcfae72'}\n\n```{.r .cell-code}\nepi_all <- fit_multi(\n  time_col = \"t\",\n  intensity_col = \"inc\",\n  data = pepper2,\n  strata_cols = \"treat\",\n  nlin = FALSE\n)\n```\n:::\n\n\nNow let's select the statistics of model fitting. Again, *Epifitter* ranks the models based on the CCC (the higher the better) but it is important to check the RSE as well - the lower the better. In fact, the RSE is more important when the goal is prediction.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-21_a916e7f882052b924b695795689f7867'}\n\n```{.r .cell-code}\nepi_all$Parameters |> \n  select(treat, model, best_model, RSE, CCC)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   treat         model best_model       RSE       CCC\n1      1      Gompertz          1 0.5911056 0.9847857\n2      1 Monomolecular          2 0.5431977 0.9838044\n3      1      Logistic          3 0.8235798 0.9781534\n4      1   Exponential          4 0.6705085 0.7839381\n5      2      Logistic          1 0.4523616 0.9961683\n6      2      Gompertz          2 0.8407922 0.9707204\n7      2 Monomolecular          3 1.0683633 0.9247793\n8      2   Exponential          4 1.2015809 0.8971003\n9      3      Logistic          1 0.6045243 0.9829434\n10     3      Gompertz          2 0.2262550 0.9824935\n11     3   Exponential          3 0.7705736 0.9635747\n12     3 Monomolecular          4 0.2533763 0.8591837\n```\n:::\n:::\n\n\nThe code below calculates the frequency that each model was the best. This would facilitate in the case of many epidemics to analyse.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-22_f548da1bc40c28f84e351981041a3654'}\n\n```{.r .cell-code}\nfreq_best <- epi_all$Parameters %>% \n    filter(best_model == 1) %>% \n    group_by(treat, model) %>% \n    summarise(first = n()) %>%\n  ungroup() |> \n  count(model) \nfreq_best \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  model        n\n  <chr>    <int>\n1 Gompertz     1\n2 Logistic     2\n```\n:::\n:::\n\n\nWe can see that the Logistic model was the best model in two out of three epidemics.\n\nTo be more certain about our decision, let's advance to the final step which is to produce the plots with the observed and predicted values for each assessment time by calling the `Data` dataframe of the \\``epi_all` list.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-fitted_95671dbc4a273f67b596ed672d5a2b19'}\n\n```{.r .cell-code}\nepi_all$Data |>\n filter(model %in% c(\"Gompertz\", \"Logistic\")) |> \n  ggplot(aes(time, predicted, shape = treat)) +\n  geom_point(aes(time, y)) +\n  geom_line() +\n  facet_wrap(~ model) +\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"bottom\")+\n coord_cartesian(ylim = c(0, 1)) + # set the max to 0.6\n  labs(\n    shape = \"Epidemic\",\n    y = \"Disease incidence\",\n    x = \"Time (days after emergence)\"\n  )\n```\n\n::: {.cell-output-display}\n![Observed (dots) and fitted (line) values for three tobacco etch epidemics in pepper](temporal-fitting_files/figure-html/fig-fitted-1.png){#fig-fitted width=672}\n:::\n:::\n\n\nOverall, the logistic model seems a better fit for all the curves. Let's produce a plot with the prediction error versus time.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-error_2765ab9cbe8623ed7a111aad3ea5250e'}\n\n```{.r .cell-code}\nepi_all$Data |>\n filter(model %in% c(\"Gompertz\", \"Logistic\")) |> \n  ggplot(aes(time, predicted -y, shape = treat)) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point() +\n  geom_line() +\n  geom_hline(yintercept = 0, linetype =2)+\n  facet_wrap(~ model) +\n coord_cartesian(ylim = c(-0.4, 0.4)) + # set the max to 0.6\n  labs(\n    y = \"Prediction error\",\n    x = \"Time (days after emergence)\",\n    shape = \"Epidemic\"\n  )\n```\n\n::: {.cell-output-display}\n![Prediction error (dotted lines) by two models fitted to the progress curves of three tobacco etch epidemics in pepper](temporal-fitting_files/figure-html/fig-error-1.png){#fig-error width=672}\n:::\n:::\n\n\nThe plots above confirms the logistic model as good fit overall because the errors for all epidemics combined are more scattered around the non-error line.\n\nWe can then now extract the parameters of interest of the chosen model. These data are stored in the `Parameters` data frame of the `epi_all` list. Let's filter the Logistic model and apply a selection of the parameters of interest.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-25_d63489a209afc27437c43493b222d70b'}\n\n```{.r .cell-code}\n  epi_all$Parameters |>\n    filter(model == \"Logistic\") |>\n    select(treat, y0, y0_ci_lwr, y0_ci_upr, r, r_ci_lwr, r_ci_upr \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  treat           y0    y0_ci_lwr   y0_ci_upr         r  r_ci_lwr  r_ci_upr\n1     1 0.0935037690 0.0273207272 0.274728744 0.2104047 0.1659824 0.2548270\n2     2 0.0013727579 0.0006723537 0.002800742 0.2784814 0.2540818 0.3028809\n3     3 0.0008132926 0.0003131745 0.002110379 0.1752146 0.1426077 0.2078215\n```\n:::\n:::\n\n\nWe can produce a plot for visual inference on the differences in the parameters.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-params_37ba04f2b5a6bb601efeb408b675e956'}\n\n```{.r .cell-code}\np1 <- epi_all$Parameters |>\n  filter(model == \"Logistic\") |>\n  ggplot(aes(treat, r)) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(size = 3) +\n  geom_errorbar(aes(ymin = r_ci_lwr, ymax = r_ci_upr),\n    width = 0,\n    size = 1\n  ) +\n  labs(\n    x = \"Epidemic\",\n    y = \"r\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n```{.r .cell-code}\np2 <- epi_all$Parameters |>\n  filter(model == \"Logistic\") |>\n  ggplot(aes(treat, 1 - exp(-y0))) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(size = 3) +\n  geom_errorbar(aes(ymin = y0_ci_lwr, ymax = y0_ci_upr),\n    width = 0,\n    size = 1\n  ) +\n  labs(\n    x = \"Epidemic\",\n    y = \"y0\"\n  )\n\nlibrary(patchwork)\np1 | p2\n```\n\n::: {.cell-output-display}\n![Estimated infection rates (left) and initial inoculum (right) by a logistic model fitted to the progress curves of three epidemics of tobacco etch on pepper](temporal-fitting_files/figure-html/fig-params-1.png){#fig-params width=672}\n:::\n:::\n\n\nWe can compare the rate parameter (slopes) from two separate linear regression models using a t-test. This is sometimes referred to as a \"test of parallelism\" in the context of comparing slopes. The t-statistic for comparing two slopes with their respective standard errors can be calculated as:\n\n$t = \\frac{\\beta_1 - \\beta_2}{\\sqrt{SE_{\\beta_1}^2 + SE_{\\beta_2}^2}}$\n\nThis t-statistic follows a t-distribution with ( df = n_1 + n_2 - 4 ) degrees of freedom, where ( n_1 ) and ( n_2 ) are the sample sizes of the two groups. In our case, ( n_1 = n_2 = 8 ), so ( df = 8 + 8 - 4 = 12 ).\n\nHere's how to perform the t-test for comparing curve 1 and 2.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-27_eff493a68f9c6b9dba6d44b99360cb6a'}\n\n```{.r .cell-code}\n# Given slopes and standard errors from curve 1 and 2\nbeta1 <- 0.2104\t\nbeta2 <- 0.2784\t\nSE_beta1 <- 0.01815 \nSE_beta2 <- 0.00997\n\n# Sample sizes for both treatments (n1 and n2)\nn1 <- 8\nn2 <- 8\n\n# Calculate the t-statistic\nt_statistic <- abs(beta1 - beta2) / sqrt(SE_beta1^2 + SE_beta2^2)\n\n# Degrees of freedom\ndf <- n1 + n2 - 4\n\n# Calculate the p-value\np_value <- 2 * (1 - pt(abs(t_statistic), df))\n\n# Print the results\nprint(paste(\"t-statistic:\", round(t_statistic, 4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"t-statistic: 3.2837\"\n```\n:::\n\n```{.r .cell-code}\nprint(paste(\"Degrees of freedom:\", df))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Degrees of freedom: 12\"\n```\n:::\n\n```{.r .cell-code}\nprint(paste(\"p-value:\", round(p_value, 4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"p-value: 0.0065\"\n```\n:::\n:::\n\n\nThe `pt()` function in R gives the cumulative distribution function of the t-distribution. The `2 * (1 - pt(abs(t_statistic), df))` line calculates the two-tailed p-value. This will tell us if the slopes are significantly different at your chosen alpha level (commonly 0.05).\n\n## Designed experiments\n\nIn the following section, we'll focus on disease data collected over time from the same plot unit, also known as repeated measures. This data comes from a designed experiment aimed at evaluating and comparing the effects of different treatments.\n\nSpecifically, we'll use a dataset of progress curves found on page 98 of \"Study of Plant Disease Epidemics\" [@chapter2017b]. These curves depict the incidence of soybean plants showing symptoms of bud blight, which is caused by the tobacco streak virus. Four different treatments, corresponding to different planting dates, were evaluated using a randomized complete block design with four replicates. Each curve has four time-based assessments.\n\nThe data for this study is stored in a CSV file, which we'll load into our environment using the read_csv() function. Once loaded, we'll store the data in a dataframe named budblight.\n\n### Loading data\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-28_790b18330179c415e371591bd5b012c9'}\n\n```{.r .cell-code}\nbudblight <- read_csv(\"https://raw.githubusercontent.com/emdelponte/epidemiology-R/main/data/bud-blight-soybean.csv\")\n```\n:::\n\n\nLet's have a look at the first six rows of the dataset and check the data type for each column. There is an additional column representing the replicates, called block.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-29_068429655607fe075d182eb0bb0a13f7'}\n\n```{.r .cell-code}\nbudblight\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 64 × 4\n   treat  time block     y\n   <chr> <dbl> <dbl> <dbl>\n 1 PD1      30     1  0.1 \n 2 PD1      30     2  0.3 \n 3 PD1      30     3  0.1 \n 4 PD1      30     4  0.1 \n 5 PD1      40     1  0.3 \n 6 PD1      40     2  0.38\n 7 PD1      40     3  0.36\n 8 PD1      40     4  0.37\n 9 PD1      50     1  0.57\n10 PD1      50     2  0.52\n# ℹ 54 more rows\n```\n:::\n:::\n\n\n### Visualizing the DPCs\n\nLet's have a look at the curves and produce a combo plot figure similar to Fig. 4.17 of the book, but without the line of the predicted values.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-bud1_2606ec23c41e4b436a489cedb95fa8b5'}\n\n```{.r .cell-code}\np3 <- budblight |>\n  ggplot(aes(\n    time, y,\n    group = block,\n    shape = factor(block)\n  )) +\n  geom_point(size = 1.5) +\n  ylim(0, 0.6) +\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")+\n  facet_wrap(~treat, ncol =1)+\n  labs(y = \"Disease incidence\",\n       x = \"Time (days after emergence)\")\n\np4 <- budblight |>\n  ggplot(aes(\n    time, log(1 / (1 - y)),\n    group = block,\n    shape = factor(block)\n  )) +\n  geom_point(size = 2) +\n  facet_wrap(~treat, ncol = 1) +\n  scale_color_grey()+\n  theme_grey()+\n  theme(legend.position = \"none\")+\n  labs(y = \"Transformed incidence\", x = \"Time (days after emergence)\")\nlibrary(patchwork)\np3 | p4\n```\n\n::: {.cell-output-display}\n![Disease progress curves for the incidence of budblight of soybean in Brazil for four planting dates](temporal-fitting_files/figure-html/fig-bud1-1.png){#fig-bud1 width=768}\n:::\n:::\n\n\n### Model fitting\n\nRemember that the first step in model selection is the visual appraisal of the curve data linearized with the model transformation. In the case the curves represent complete epidemics (close to 100%) appraisal of the absolute rate (difference in y between two times) over time is also helpful.\n\nFor the treatments above, it looks like the curves are typical of a monocyclic disease (the case of soybean bud blight), for which the monomolecular is usually a good fit, but other models are also possible as well. For this exercise, we will use both the linear and the nonlinear estimation method.\n\n#### Linear regression\n\nFor convenience, we use the `fit_multi()` to handle multiple epidemics. The function returns a list object where a series of statistics are provided to aid in model selection and parameter estimation. We need to provide the names of columns (arguments): assessment time (`time_col`), disease incidence (`intensity_col`), and treatment (`strata_cols`).\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-31_8739a0d1e23eeb783f46fe4bde129258'}\n\n```{.r .cell-code}\nlin1 <- fit_multi(\n  time_col = \"time\",\n  intensity_col = \"y\",\n  data = budblight,\n  strata_cols = \"treat\",\n  nlin = FALSE\n)\n```\n:::\n\n\nLet's look at how well the four models fitted the data. Epifitter suggests the best fitted model (1 to 4, where 1 is best) for each treatment. Let's have a look at the statistics of model fitting.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-32_22f32483df17782ed9980c96fbc5795b'}\n\n```{.r .cell-code}\nlin1$Parameters |> \nselect(treat, best_model, model, CCC, RSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   treat best_model         model       CCC        RSE\n1    PD1          1 Monomolecular 0.9348429 0.09805661\n2    PD1          2      Gompertz 0.9040182 0.22226189\n3    PD1          3      Logistic 0.8711178 0.44751963\n4    PD1          4   Exponential 0.8278055 0.36124036\n5    PD2          1 Monomolecular 0.9547434 0.07003116\n6    PD2          2      Gompertz 0.9307192 0.17938711\n7    PD2          3      Logistic 0.9062012 0.38773023\n8    PD2          4   Exponential 0.8796705 0.32676216\n9    PD3          1 Monomolecular 0.9393356 0.06832499\n10   PD3          2      Gompertz 0.9288436 0.17156394\n11   PD3          3      Logistic 0.9085414 0.39051075\n12   PD3          4   Exponential 0.8896173 0.33884790\n13   PD4          1      Gompertz 0.9234736 0.17474422\n14   PD4          2 Monomolecular 0.8945962 0.06486949\n15   PD4          3      Logistic 0.8911344 0.52412586\n16   PD4          4   Exponential 0.8739618 0.49769642\n```\n:::\n:::\n\n\nAnd now we extract values for each parameter estimated from the fit of the monomolecular model.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-33_fd46bda1e00caf1e8d5f766ead965dd3'}\n\n```{.r .cell-code}\nlin1$Parameters |>\nfilter(model == \"Monomolecular\") |>\nselect(treat, y0, r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  treat         y0          r\n1   PD1 -0.5727700 0.02197351\n2   PD2 -0.5220593 0.01902952\n3   PD3 -0.4491365 0.01590586\n4   PD4 -0.3619898 0.01118047\n```\n:::\n:::\n\n\nNow we visualize the fit of the monomolecular model (using `filter` function - see below) to the data together with the observed data and then reproduce the right plots in Fig. 4.17 from the book.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-bud2_2de4d088db23f6af513c16c0351abb2a'}\n\n```{.r .cell-code}\nlin1$Data |>\n  filter(model == \"Monomolecular\") |>\n  ggplot(aes(time, predicted)) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(aes(time, y)) +\n  geom_line(size = 0.5) +\n  facet_wrap(~treat) +\n  coord_cartesian(ylim = c(0, 0.6)) + # set the max to 0.6\n  labs(\n    y = \"Disease incidence\",\n    x = \"Time (days after emergence)\"\n  )\n```\n\n::: {.cell-output-display}\n![Observed (dot) and fitted values by a monomolecular model (line) to the data on the incidence of budblight of soybean in Brazil for four planting dates](temporal-fitting_files/figure-html/fig-bud2-1.png){#fig-bud2 width=672}\n:::\n:::\n\n\nNow we can plot the means and respective 95% confidence interval of the apparent infection rate ($r$) and initial inoculum ($y_0$) for visual inference.\n\n\n::: {.cell hash='temporal-fitting_cache/html/fig-bud3_8ac76a38434530f9b22f431e69332dda'}\n\n```{.r .cell-code}\np5 <- lin1$Parameters |>\n  filter(model == \"Monomolecular\") |>\n  ggplot(aes(treat, r)) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(size = 3) +\n  geom_errorbar(aes(ymin = r_ci_lwr, ymax = r_ci_upr),\n    width = 0,\n    size = 1\n  ) +\n  labs(\n    x = \"Epidemic\",\n    y = \"Infection rate (r)\"\n  )\n\np6 <- lin1$Parameters |>\n  filter(model == \"Monomolecular\") |>\n  ggplot(aes(treat, 1 - exp(-y0))) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(size = 3) +\n  geom_errorbar(aes(ymin = y0_ci_lwr, ymax = y0_ci_upr),\n    width = 0,\n    size = 1\n  ) +\n  labs(\n    x = \"Time\",\n    y = \"Initial inoculum (y0)\"\n  )\np5 | p6\n```\n\n::: {.cell-output-display}\n![Estimates of the infection rate (left) and initial inoculum (right) from the fit of a monomolecular model  to the data on the incidence of budblight of soybean in Brazil for four planting dates](temporal-fitting_files/figure-html/fig-bud3-1.png){#fig-bud3 width=672}\n:::\n:::\n\n\n#### Non-linear regression\n\nTo estimate the parameters using the non-linear approach, we repeat the same arguments in the `fit_multi` function, but include an additional argument `nlin` set to `TRUE`.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-36_6bdd0cd1efdc70769ca3da4576385849'}\n\n```{.r .cell-code}\nnlin1 <- fit_multi(\n  time_col = \"time\",\n  intensity_col = \"y\",\n  data = budblight,\n  strata_cols = \"treat\",\n  nlin = TRUE\n)\n```\n:::\n\n\nLet's check statistics of model fit.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-37_0c8ebefe7b755376559a6f4cd8d1ef63'}\n\n```{.r .cell-code}\nnlin1$Parameters |>\nselect(treat, model, CCC, RSE, best_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   treat         model       CCC        RSE best_model\n1    PD1 Monomolecular 0.9382991 0.06133704          1\n2    PD1      Gompertz 0.9172407 0.06986307          2\n3    PD1      Logistic 0.8957351 0.07700720          3\n4    PD1   Exponential 0.8544194 0.08799512          4\n5    PD2 Monomolecular 0.9667886 0.04209339          1\n6    PD2      Gompertz 0.9348370 0.05726761          2\n7    PD2      Logistic 0.9077857 0.06657793          3\n8    PD2   Exponential 0.8702365 0.07667322          4\n9    PD3 Monomolecular 0.9570853 0.04269129          1\n10   PD3      Gompertz 0.9261609 0.05443852          2\n11   PD3      Logistic 0.8997106 0.06203037          3\n12   PD3   Exponential 0.8703443 0.06891021          4\n13   PD4 Monomolecular 0.9178226 0.04595409          1\n14   PD4      Gompertz 0.9085579 0.04791331          2\n15   PD4      Logistic 0.8940731 0.05083336          3\n16   PD4   Exponential 0.8842437 0.05267415          4\n```\n:::\n:::\n\n\nAnd now we obtain the two parameters of interest. Note that the values are not the sames as those estimated using linear regression, but they are similar and highly correlated.\n\n\n::: {.cell hash='temporal-fitting_cache/html/unnamed-chunk-38_80bfc230cf8173ff2474c1d3654185d8'}\n\n```{.r .cell-code}\nnlin1$Parameters |>\nfilter(model == \"Monomolecular\") |>\nselect(treat, y0, r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  treat         y0          r\n1   PD1 -0.7072562 0.02381573\n2   PD2 -0.6335713 0.02064629\n3   PD3 -0.5048763 0.01674209\n4   PD4 -0.3501234 0.01094368\n```\n:::\n:::\n\n::: {.cell hash='temporal-fitting_cache/html/fig-bud4_ba8b9e46d596b467f91cdf7d6d87404e'}\n\n```{.r .cell-code}\np7 <- nlin1$Parameters |>\n  filter(model == \"Monomolecular\") |>\n  ggplot(aes(treat, r)) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(size = 3) +\n  geom_errorbar(aes(ymin = r_ci_lwr, ymax = r_ci_upr),\n    width = 0,\n    size = 1\n  ) +\n  labs(\n    x = \"Epidemic\",\n    y = \"Infection rate (r)\"\n  )\n\np8 <- nlin1$Parameters |>\n  filter(model == \"Monomolecular\") |>\n  ggplot(aes(treat, y0)) +\n  scale_color_grey()+\n  theme_grey()+\n  geom_point(size = 3) +\n  geom_errorbar(aes(ymin = y0_ci_lwr, ymax = y0_ci_upr),\n    width = 0,\n    size = 1\n  ) +\n  labs(\n    x = \"Epidemic\",\n    y = \"Initial inoculum (y0)\"\n  )\n\np7 | p8\n```\n\n::: {.cell-output-display}\n![Estimates of the infection rate (left) and initial inoculum (right) from the fit of a monomolecular model  to the data on the incidence of budblight of soybean in Brazil for four planting dates](temporal-fitting_files/figure-html/fig-bud4-1.png){#fig-bud4 width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}